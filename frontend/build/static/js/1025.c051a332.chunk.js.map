{"version":3,"file":"static/js/1025.c051a332.chunk.js","mappings":"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","sources":["../node_modules/viem/utils/abi/encodePacked.ts","../node_modules/idb-keyval/dist/index.js","../node_modules/viem/account-abstraction/utils/userOperation/getInitCode.ts","../node_modules/viem/account-abstraction/utils/userOperation/toPackedUserOperation.ts","../node_modules/viem/account-abstraction/utils/userOperation/getUserOperationTypedData.ts","../node_modules/viem/account-abstraction/utils/userOperation/getUserOperationHash.ts","../node_modules/viem/account-abstraction/constants/address.ts","../node_modules/zustand/esm/vanilla.mjs","../node_modules/viem/account-abstraction/constants/abis.ts","../node_modules/zustand/esm/middleware.mjs","../node_modules/viem/account-abstraction/errors/bundler.ts","../node_modules/viem/account-abstraction/errors/userOperation.ts","../node_modules/viem/account-abstraction/utils/errors/getBundlerError.ts","../node_modules/viem/account-abstraction/utils/errors/getUserOperationError.ts","../node_modules/viem/account-abstraction/utils/formatters/userOperationRequest.ts","../node_modules/viem/account-abstraction/actions/paymaster/getPaymasterData.ts","../node_modules/viem/account-abstraction/actions/paymaster/getPaymasterStubData.ts","../node_modules/viem/account-abstraction/actions/bundler/prepareUserOperation.ts","../node_modules/viem/actions/wallet/prepareAuthorization.ts","../node_modules/viem/account-abstraction/actions/bundler/estimateUserOperationGas.ts","../node_modules/viem/account-abstraction/utils/formatters/userOperationGas.ts","../node_modules/viem/account-abstraction/utils/formatters/userOperation.ts","../node_modules/viem/account-abstraction/actions/bundler/getUserOperationReceipt.ts","../node_modules/viem/account-abstraction/utils/formatters/userOperationReceipt.ts","../node_modules/viem/account-abstraction/clients/decorators/bundler.ts","../node_modules/viem/account-abstraction/actions/bundler/getSupportedEntryPoints.ts","../node_modules/viem/account-abstraction/actions/bundler/getUserOperation.ts","../node_modules/viem/account-abstraction/actions/bundler/sendUserOperation.ts","../node_modules/viem/account-abstraction/actions/bundler/waitForUserOperationReceipt.ts","../node_modules/viem/account-abstraction/clients/createBundlerClient.ts","../node_modules/viem/utils/signature/parseSignature.ts","../node_modules/viem/errors/calls.ts","../node_modules/viem/actions/wallet/sendCalls.ts","../node_modules/viem/actions/wallet/getCallsStatus.ts","../node_modules/viem/actions/wallet/waitForCallsStatus.ts","../node_modules/viem/utils/nonceManager.ts","../node_modules/viem/constants/bytes.ts","../node_modules/viem/utils/signature/serializeErc6492Signature.ts","../node_modules/viem/account-abstraction/accounts/toSmartAccount.ts","../node_modules/viem/clients/createPublicClient.ts","../node_modules/@noble/curves/src/nist.ts","../node_modules/@noble/curves/src/p256.ts"],"sourcesContent":["import type {\n  AbiParameterToPrimitiveType,\n  AbiType,\n  Address,\n  SolidityAddress,\n  SolidityArrayWithoutTuple,\n  SolidityBool,\n  SolidityBytes,\n  SolidityInt,\n  SolidityString,\n} from 'abitype'\n\nimport {\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  BytesSizeMismatchError,\n  type BytesSizeMismatchErrorType,\n  UnsupportedPackedAbiType,\n} from '../../errors/abi.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\nimport {\n  type BoolToHexErrorType,\n  boolToHex,\n  type NumberToHexErrorType,\n  numberToHex,\n  type StringToHexErrorType,\n  stringToHex,\n} from '../encoding/toHex.js'\nimport { arrayRegex, bytesRegex, integerRegex } from '../regex.js'\n\ntype PackedAbiType =\n  | SolidityAddress\n  | SolidityBool\n  | SolidityBytes\n  | SolidityInt\n  | SolidityString\n  | SolidityArrayWithoutTuple\n\ntype EncodePackedValues<\n  packedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n> = {\n  [K in keyof packedAbiTypes]: packedAbiTypes[K] extends AbiType\n    ? AbiParameterToPrimitiveType<{ type: packedAbiTypes[K] }>\n    : unknown\n}\n\nexport type EncodePackedErrorType =\n  | AbiEncodingLengthMismatchErrorType\n  | ConcatHexErrorType\n  | EncodeErrorType\n  | ErrorType\n\nexport function encodePacked<\n  const packedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n>(types: packedAbiTypes, values: EncodePackedValues<packedAbiTypes>): Hex {\n  if (types.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: types.length as number,\n      givenLength: values.length as number,\n    })\n\n  const data: Hex[] = []\n  for (let i = 0; i < (types as unknown[]).length; i++) {\n    const type = types[i]\n    const value = values[i]\n    data.push(encode(type, value))\n  }\n  return concatHex(data)\n}\n\ntype EncodeErrorType =\n  | BoolToHexErrorType\n  | BytesSizeMismatchErrorType\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | PadErrorType\n  | StringToHexErrorType\n  | UnsupportedPackedAbiType\n  | ErrorType\n\nfunction encode<const packedAbiType extends PackedAbiType | unknown>(\n  type: packedAbiType,\n  value: EncodePackedValues<[packedAbiType]>[0],\n  isArray = false,\n): Hex {\n  if (type === 'address') {\n    const address = value as Address\n    if (!isAddress(address)) throw new InvalidAddressError({ address })\n    return pad(address.toLowerCase() as Hex, {\n      size: isArray ? 32 : null,\n    }) as Address\n  }\n  if (type === 'string') return stringToHex(value as string)\n  if (type === 'bytes') return value as Hex\n  if (type === 'bool')\n    return pad(boolToHex(value as boolean), { size: isArray ? 32 : 1 })\n\n  const intMatch = (type as string).match(integerRegex)\n  if (intMatch) {\n    const [_type, baseType, bits = '256'] = intMatch\n    const size = Number.parseInt(bits, 10) / 8\n    return numberToHex(value as number, {\n      size: isArray ? 32 : size,\n      signed: baseType === 'int',\n    })\n  }\n\n  const bytesMatch = (type as string).match(bytesRegex)\n  if (bytesMatch) {\n    const [_type, size] = bytesMatch\n    if (Number.parseInt(size, 10) !== ((value as Hex).length - 2) / 2)\n      throw new BytesSizeMismatchError({\n        expectedSize: Number.parseInt(size, 10),\n        givenSize: ((value as Hex).length - 2) / 2,\n      })\n    return pad(value as Hex, { dir: 'right', size: isArray ? 32 : null }) as Hex\n  }\n\n  const arrayMatch = (type as string).match(arrayRegex)\n  if (arrayMatch && Array.isArray(value)) {\n    const [_type, childType] = arrayMatch\n    const data: Hex[] = []\n    for (let i = 0; i < value.length; i++) {\n      data.push(encode(childType, value[i], true))\n    }\n    if (data.length === 0) return '0x'\n    return concatHex(data)\n  }\n\n  throw new UnsupportedPackedAbiType(type)\n}\n","function promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n        // @ts-ignore - file size hacks\n        request.oncomplete = request.onsuccess = () => resolve(request.result);\n        // @ts-ignore - file size hacks\n        request.onabort = request.onerror = () => reject(request.error);\n    });\n}\nfunction createStore(dbName, storeName) {\n    const request = indexedDB.open(dbName);\n    request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n    const dbp = promisifyRequest(request);\n    return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));\n}\nlet defaultGetStoreFunc;\nfunction defaultGetStore() {\n    if (!defaultGetStoreFunc) {\n        defaultGetStoreFunc = createStore('keyval-store', 'keyval');\n    }\n    return defaultGetStoreFunc;\n}\n/**\n * Get a value by its key.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction get(key, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => promisifyRequest(store.get(key)));\n}\n/**\n * Set a value with a key.\n *\n * @param key\n * @param value\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction set(key, value, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.put(value, key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Set multiple values at once. This is faster than calling set() multiple times.\n * It's also atomic  if one of the pairs can't be added, none will be added.\n *\n * @param entries Array of entries, where each entry is an array of `[key, value]`.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction setMany(entries, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        entries.forEach((entry) => store.put(entry[1], entry[0]));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Get multiple values by their keys\n *\n * @param keys\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction getMany(keys, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => Promise.all(keys.map((key) => promisifyRequest(store.get(key)))));\n}\n/**\n * Update a value. This lets you see the old value and update it as an atomic operation.\n *\n * @param key\n * @param updater A callback that takes the old value and returns a new value.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction update(key, updater, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => \n    // Need to create the promise manually.\n    // If I try to chain promises, the transaction closes in browsers\n    // that use a promise polyfill (IE10/11).\n    new Promise((resolve, reject) => {\n        store.get(key).onsuccess = function () {\n            try {\n                store.put(updater(this.result), key);\n                resolve(promisifyRequest(store.transaction));\n            }\n            catch (err) {\n                reject(err);\n            }\n        };\n    }));\n}\n/**\n * Delete a particular key from the store.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction del(key, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.delete(key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Delete multiple keys at once.\n *\n * @param keys List of keys to delete.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction delMany(keys, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        keys.forEach((key) => store.delete(key));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Clear all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction clear(customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.clear();\n        return promisifyRequest(store.transaction);\n    });\n}\nfunction eachCursor(store, callback) {\n    store.openCursor().onsuccess = function () {\n        if (!this.result)\n            return;\n        callback(this.result);\n        this.result.continue();\n    };\n    return promisifyRequest(store.transaction);\n}\n/**\n * Get all keys in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction keys(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAllKeys) {\n            return promisifyRequest(store.getAllKeys());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);\n    });\n}\n/**\n * Get all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction values(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAll) {\n            return promisifyRequest(store.getAll());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.value)).then(() => items);\n    });\n}\n/**\n * Get all entries in the store. Each entry is an array of `[key, value]`.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction entries(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        // (although, hopefully we'll get a simpler path some day)\n        if (store.getAll && store.getAllKeys) {\n            return Promise.all([\n                promisifyRequest(store.getAllKeys()),\n                promisifyRequest(store.getAll()),\n            ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]));\n        }\n        const items = [];\n        return customStore('readonly', (store) => eachCursor(store, (cursor) => items.push([cursor.key, cursor.value])).then(() => items));\n    });\n}\n\nexport { clear, createStore, del, delMany, entries, get, getMany, keys, promisifyRequest, set, setMany, update, values };\n","import { concat } from '../../../utils/data/concat.js'\nimport type { UserOperation } from '../../types/userOperation.js'\n\nexport function getInitCode(\n  userOperation: Pick<\n    UserOperation,\n    'authorization' | 'factory' | 'factoryData'\n  >,\n) {\n  const { authorization, factory, factoryData } = userOperation\n  if (\n    factory === '0x7702' ||\n    factory === '0x7702000000000000000000000000000000000000'\n  ) {\n    if (!authorization) return '0x7702000000000000000000000000000000000000'\n    const delegation = authorization.address\n    return concat([delegation, factoryData ?? '0x'])\n  }\n  if (!factory) return '0x'\n  return concat([factory, factoryData ?? '0x'])\n}\n","import { concat } from '../../../utils/data/concat.js'\nimport { pad } from '../../../utils/data/pad.js'\nimport { numberToHex } from '../../../utils/index.js'\nimport type {\n  PackedUserOperation,\n  UserOperation,\n} from '../../types/userOperation.js'\nimport { getInitCode } from './getInitCode.js'\n\nexport function toPackedUserOperation(\n  userOperation: UserOperation,\n): PackedUserOperation {\n  const {\n    callGasLimit,\n    callData,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n    paymaster,\n    paymasterData,\n    paymasterPostOpGasLimit,\n    paymasterVerificationGasLimit,\n    sender,\n    signature = '0x',\n    verificationGasLimit,\n  } = userOperation\n\n  const accountGasLimits = concat([\n    pad(numberToHex(verificationGasLimit || 0n), { size: 16 }),\n    pad(numberToHex(callGasLimit || 0n), { size: 16 }),\n  ])\n  const initCode = getInitCode(userOperation)\n  const gasFees = concat([\n    pad(numberToHex(maxPriorityFeePerGas || 0n), { size: 16 }),\n    pad(numberToHex(maxFeePerGas || 0n), { size: 16 }),\n  ])\n  const nonce = userOperation.nonce ?? 0n\n  const paymasterAndData = paymaster\n    ? concat([\n        paymaster,\n        pad(numberToHex(paymasterVerificationGasLimit || 0n), {\n          size: 16,\n        }),\n        pad(numberToHex(paymasterPostOpGasLimit || 0n), {\n          size: 16,\n        }),\n        paymasterData || '0x',\n      ])\n    : '0x'\n  const preVerificationGas = userOperation.preVerificationGas ?? 0n\n\n  return {\n    accountGasLimits,\n    callData,\n    initCode,\n    gasFees,\n    nonce,\n    paymasterAndData,\n    preVerificationGas,\n    sender,\n    signature,\n  }\n}\n","import type { Address } from 'abitype'\n\nimport type { TypedDataDefinition } from '../../../types/typedData.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport { toPackedUserOperation } from './toPackedUserOperation.js'\n\nexport type GetUserOperationTypedDataParameters = {\n  chainId: number\n  entryPointAddress: Address\n  userOperation: UserOperation<'0.8'>\n}\n\nexport type GetUserOperationTypedDataReturnType = TypedDataDefinition<\n  typeof types,\n  'PackedUserOperation'\n>\n\nconst types = {\n  PackedUserOperation: [\n    { type: 'address', name: 'sender' },\n    { type: 'uint256', name: 'nonce' },\n    { type: 'bytes', name: 'initCode' },\n    { type: 'bytes', name: 'callData' },\n    { type: 'bytes32', name: 'accountGasLimits' },\n    { type: 'uint256', name: 'preVerificationGas' },\n    { type: 'bytes32', name: 'gasFees' },\n    { type: 'bytes', name: 'paymasterAndData' },\n  ],\n} as const\n\nexport function getUserOperationTypedData(\n  parameters: GetUserOperationTypedDataParameters,\n): GetUserOperationTypedDataReturnType {\n  const { chainId, entryPointAddress, userOperation } = parameters\n\n  const packedUserOp = toPackedUserOperation(userOperation)\n\n  return {\n    types,\n    primaryType: 'PackedUserOperation',\n    domain: {\n      name: 'ERC4337',\n      version: '1',\n      chainId,\n      verifyingContract: entryPointAddress,\n    },\n    message: packedUserOp,\n  }\n}\n","import type { Address } from 'abitype'\n\nimport type { Hash, Hex } from '../../../types/misc.js'\nimport { encodeAbiParameters } from '../../../utils/abi/encodeAbiParameters.js'\nimport { keccak256 } from '../../../utils/hash/keccak256.js'\nimport { hashTypedData } from '../../../utils/signature/hashTypedData.js'\nimport type { EntryPointVersion } from '../../types/entryPointVersion.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport { getInitCode } from './getInitCode.js'\nimport { getUserOperationTypedData } from './getUserOperationTypedData.js'\nimport { toPackedUserOperation } from './toPackedUserOperation.js'\n\nexport type GetUserOperationHashParameters<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> = {\n  chainId: number\n  entryPointAddress: Address\n  entryPointVersion: entryPointVersion | EntryPointVersion\n  userOperation: UserOperation<entryPointVersion>\n}\n\nexport type GetUserOperationHashReturnType = Hash\n\nexport function getUserOperationHash<\n  entryPointVersion extends EntryPointVersion,\n>(\n  parameters: GetUserOperationHashParameters<entryPointVersion>,\n): GetUserOperationHashReturnType {\n  const { chainId, entryPointAddress, entryPointVersion } = parameters\n  const userOperation = parameters.userOperation as UserOperation\n  const {\n    authorization,\n    callData = '0x',\n    callGasLimit,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    paymasterAndData = '0x',\n    preVerificationGas,\n    sender,\n    verificationGasLimit,\n  } = userOperation\n\n  if (entryPointVersion === '0.8')\n    return hashTypedData(\n      getUserOperationTypedData({\n        chainId,\n        entryPointAddress,\n        userOperation,\n      }),\n    )\n\n  const packedUserOp = (() => {\n    if (entryPointVersion === '0.6') {\n      const factory = userOperation.initCode?.slice(0, 42) as Hex\n      const factoryData = userOperation.initCode?.slice(42) as Hex | undefined\n      const initCode = getInitCode({\n        authorization,\n        factory,\n        factoryData,\n      })\n      return encodeAbiParameters(\n        [\n          { type: 'address' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n        ],\n        [\n          sender,\n          nonce,\n          keccak256(initCode),\n          keccak256(callData),\n          callGasLimit,\n          verificationGasLimit,\n          preVerificationGas,\n          maxFeePerGas,\n          maxPriorityFeePerGas,\n          keccak256(paymasterAndData),\n        ],\n      )\n    }\n\n    if (entryPointVersion === '0.7') {\n      const packedUserOp = toPackedUserOperation(userOperation)\n      return encodeAbiParameters(\n        [\n          { type: 'address' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n        ],\n        [\n          packedUserOp.sender,\n          packedUserOp.nonce,\n          keccak256(packedUserOp.initCode),\n          keccak256(packedUserOp.callData),\n          packedUserOp.accountGasLimits,\n          packedUserOp.preVerificationGas,\n          packedUserOp.gasFees,\n          keccak256(packedUserOp.paymasterAndData),\n        ],\n      )\n    }\n\n    throw new Error(`entryPointVersion \"${entryPointVersion}\" not supported.`)\n  })()\n\n  return keccak256(\n    encodeAbiParameters(\n      [{ type: 'bytes32' }, { type: 'address' }, { type: 'uint256' }],\n      [keccak256(packedUserOp), entryPointAddress, BigInt(chainId)],\n    ),\n  )\n}\n","export const entryPoint06Address =\n  '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789' as const\nexport const entryPoint07Address =\n  '0x0000000071727De22E5E9d8BAf0edAc6f37da032' as const\nexport const entryPoint08Address =\n  '0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108' as const\n","const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const api = { setState, getState, getInitialState, subscribe };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\n\nexport { createStore };\n","export const entryPoint06Abi = [\n  {\n    inputs: [\n      { name: 'preOpGas', type: 'uint256' },\n      { name: 'paid', type: 'uint256' },\n      { name: 'validAfter', type: 'uint48' },\n      { name: 'validUntil', type: 'uint48' },\n      { name: 'targetSuccess', type: 'bool' },\n      { name: 'targetResult', type: 'bytes' },\n    ],\n    name: 'ExecutionResult',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { name: 'opIndex', type: 'uint256' },\n      { name: 'reason', type: 'string' },\n    ],\n    name: 'FailedOp',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'sender', type: 'address' }],\n    name: 'SenderAddressResult',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'aggregator', type: 'address' }],\n    name: 'SignatureValidationFailed',\n    type: 'error',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'preOpGas', type: 'uint256' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'sigFailed', type: 'bool' },\n          { name: 'validAfter', type: 'uint48' },\n          { name: 'validUntil', type: 'uint48' },\n          { name: 'paymasterContext', type: 'bytes' },\n        ],\n\n        name: 'returnInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'senderInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'factoryInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'paymasterInfo',\n        type: 'tuple',\n      },\n    ],\n    name: 'ValidationResult',\n    type: 'error',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'preOpGas', type: 'uint256' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'sigFailed', type: 'bool' },\n          { name: 'validAfter', type: 'uint48' },\n          { name: 'validUntil', type: 'uint48' },\n          { name: 'paymasterContext', type: 'bytes' },\n        ],\n\n        name: 'returnInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'senderInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'factoryInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'paymasterInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'aggregator', type: 'address' },\n          {\n            components: [\n              { name: 'stake', type: 'uint256' },\n              {\n                name: 'unstakeDelaySec',\n                type: 'uint256',\n              },\n            ],\n\n            name: 'stakeInfo',\n            type: 'tuple',\n          },\n        ],\n\n        name: 'aggregatorInfo',\n        type: 'tuple',\n      },\n    ],\n    name: 'ValidationResultWithAggregation',\n    type: 'error',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'factory',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n    ],\n    name: 'AccountDeployed',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'BeforeExecution', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalDeposit',\n        type: 'uint256',\n      },\n    ],\n    name: 'Deposited',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'aggregator',\n        type: 'address',\n      },\n    ],\n    name: 'SignatureAggregatorChanged',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalStaked',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'unstakeDelaySec',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeLocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawTime',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeUnlocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeWithdrawn',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      { indexed: false, name: 'success', type: 'bool' },\n      {\n        indexed: false,\n\n        name: 'actualGasCost',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'actualGasUsed',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationEvent',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'UserOperationRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'Withdrawn',\n    type: 'event',\n  },\n  {\n    inputs: [],\n    name: 'SIG_VALIDATION_FAILED',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'initCode', type: 'bytes' },\n      { name: 'sender', type: 'address' },\n      { name: 'paymasterAndData', type: 'bytes' },\n    ],\n    name: '_validateSenderAndPaymaster',\n    outputs: [],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'unstakeDelaySec', type: 'uint32' }],\n    name: 'addStake',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'balanceOf',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'depositTo',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: '', type: 'address' }],\n    name: 'deposits',\n    outputs: [\n      { name: 'deposit', type: 'uint112' },\n      { name: 'staked', type: 'bool' },\n      { name: 'stake', type: 'uint112' },\n      { name: 'unstakeDelaySec', type: 'uint32' },\n      { name: 'withdrawTime', type: 'uint48' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'getDepositInfo',\n    outputs: [\n      {\n        components: [\n          { name: 'deposit', type: 'uint112' },\n          { name: 'staked', type: 'bool' },\n          { name: 'stake', type: 'uint112' },\n          { name: 'unstakeDelaySec', type: 'uint32' },\n          { name: 'withdrawTime', type: 'uint48' },\n        ],\n\n        name: 'info',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'sender', type: 'address' },\n      { name: 'key', type: 'uint192' },\n    ],\n    name: 'getNonce',\n    outputs: [{ name: 'nonce', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'initCode', type: 'bytes' }],\n    name: 'getSenderAddress',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'getUserOpHash',\n    outputs: [{ name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              { name: 'initCode', type: 'bytes' },\n              { name: 'callData', type: 'bytes' },\n              {\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'paymasterAndData',\n                type: 'bytes',\n              },\n              { name: 'signature', type: 'bytes' },\n            ],\n\n            name: 'userOps',\n            type: 'tuple[]',\n          },\n          {\n            name: 'aggregator',\n            type: 'address',\n          },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'opsPerAggregator',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleAggregatedOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'ops',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'key', type: 'uint192' }],\n    name: 'incrementNonce',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'callData', type: 'bytes' },\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              {\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { name: 'paymaster', type: 'address' },\n              {\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n            ],\n\n            name: 'mUserOp',\n            type: 'tuple',\n          },\n          { name: 'userOpHash', type: 'bytes32' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'contextOffset', type: 'uint256' },\n          { name: 'preOpGas', type: 'uint256' },\n        ],\n\n        name: 'opInfo',\n        type: 'tuple',\n      },\n      { name: 'context', type: 'bytes' },\n    ],\n    name: 'innerHandleOp',\n    outputs: [{ name: 'actualGasCost', type: 'uint256' }],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: '', type: 'address' },\n      { name: '', type: 'uint192' },\n    ],\n    name: 'nonceSequenceNumber',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'op',\n        type: 'tuple',\n      },\n      { name: 'target', type: 'address' },\n      { name: 'targetCallData', type: 'bytes' },\n    ],\n    name: 'simulateHandleOp',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'simulateValidation',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'unlockStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n    ],\n    name: 'withdrawStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      { name: 'withdrawAmount', type: 'uint256' },\n    ],\n    name: 'withdrawTo',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n\nexport const entryPoint07Abi = [\n  {\n    inputs: [\n      { name: 'success', type: 'bool' },\n      { name: 'ret', type: 'bytes' },\n    ],\n    name: 'DelegateAndRevert',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { name: 'opIndex', type: 'uint256' },\n      { name: 'reason', type: 'string' },\n    ],\n    name: 'FailedOp',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { name: 'opIndex', type: 'uint256' },\n      { name: 'reason', type: 'string' },\n      { name: 'inner', type: 'bytes' },\n    ],\n    name: 'FailedOpWithRevert',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'returnData', type: 'bytes' }],\n    name: 'PostOpReverted',\n    type: 'error',\n  },\n  { inputs: [], name: 'ReentrancyGuardReentrantCall', type: 'error' },\n  {\n    inputs: [{ name: 'sender', type: 'address' }],\n    name: 'SenderAddressResult',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'aggregator', type: 'address' }],\n    name: 'SignatureValidationFailed',\n    type: 'error',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'factory',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n    ],\n    name: 'AccountDeployed',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'BeforeExecution', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalDeposit',\n        type: 'uint256',\n      },\n    ],\n    name: 'Deposited',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'PostOpRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'aggregator',\n        type: 'address',\n      },\n    ],\n    name: 'SignatureAggregatorChanged',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalStaked',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'unstakeDelaySec',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeLocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawTime',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeUnlocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeWithdrawn',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      { indexed: false, name: 'success', type: 'bool' },\n      {\n        indexed: false,\n\n        name: 'actualGasCost',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'actualGasUsed',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationEvent',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationPrefundTooLow',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'UserOperationRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'Withdrawn',\n    type: 'event',\n  },\n  {\n    inputs: [{ name: 'unstakeDelaySec', type: 'uint32' }],\n    name: 'addStake',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'balanceOf',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'target', type: 'address' },\n      { name: 'data', type: 'bytes' },\n    ],\n    name: 'delegateAndRevert',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'depositTo',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: '', type: 'address' }],\n    name: 'deposits',\n    outputs: [\n      { name: 'deposit', type: 'uint256' },\n      { name: 'staked', type: 'bool' },\n      { name: 'stake', type: 'uint112' },\n      { name: 'unstakeDelaySec', type: 'uint32' },\n      { name: 'withdrawTime', type: 'uint48' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'getDepositInfo',\n    outputs: [\n      {\n        components: [\n          { name: 'deposit', type: 'uint256' },\n          { name: 'staked', type: 'bool' },\n          { name: 'stake', type: 'uint112' },\n          { name: 'unstakeDelaySec', type: 'uint32' },\n          { name: 'withdrawTime', type: 'uint48' },\n        ],\n\n        name: 'info',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'sender', type: 'address' },\n      { name: 'key', type: 'uint192' },\n    ],\n    name: 'getNonce',\n    outputs: [{ name: 'nonce', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'initCode', type: 'bytes' }],\n    name: 'getSenderAddress',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          {\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'gasFees', type: 'bytes32' },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'getUserOpHash',\n    outputs: [{ name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              { name: 'initCode', type: 'bytes' },\n              { name: 'callData', type: 'bytes' },\n              {\n                name: 'accountGasLimits',\n                type: 'bytes32',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { name: 'gasFees', type: 'bytes32' },\n              {\n                name: 'paymasterAndData',\n                type: 'bytes',\n              },\n              { name: 'signature', type: 'bytes' },\n            ],\n\n            name: 'userOps',\n            type: 'tuple[]',\n          },\n          {\n            name: 'aggregator',\n            type: 'address',\n          },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'opsPerAggregator',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleAggregatedOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          {\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'gasFees', type: 'bytes32' },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'ops',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'key', type: 'uint192' }],\n    name: 'incrementNonce',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'callData', type: 'bytes' },\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              {\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'paymasterVerificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'paymasterPostOpGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { name: 'paymaster', type: 'address' },\n              {\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n            ],\n\n            name: 'mUserOp',\n            type: 'tuple',\n          },\n          { name: 'userOpHash', type: 'bytes32' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'contextOffset', type: 'uint256' },\n          { name: 'preOpGas', type: 'uint256' },\n        ],\n\n        name: 'opInfo',\n        type: 'tuple',\n      },\n      { name: 'context', type: 'bytes' },\n    ],\n    name: 'innerHandleOp',\n    outputs: [{ name: 'actualGasCost', type: 'uint256' }],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: '', type: 'address' },\n      { name: '', type: 'uint192' },\n    ],\n    name: 'nonceSequenceNumber',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'interfaceId', type: 'bytes4' }],\n    name: 'supportsInterface',\n    outputs: [{ name: '', type: 'bool' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'unlockStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n    ],\n    name: 'withdrawStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      { name: 'withdrawAmount', type: 'uint256' },\n    ],\n    name: 'withdrawTo',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n\nexport const entryPoint08Abi = [\n  { inputs: [], stateMutability: 'nonpayable', type: 'constructor' },\n  {\n    inputs: [\n      { internalType: 'bool', name: 'success', type: 'bool' },\n      { internalType: 'bytes', name: 'ret', type: 'bytes' },\n    ],\n    name: 'DelegateAndRevert',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: 'opIndex', type: 'uint256' },\n      { internalType: 'string', name: 'reason', type: 'string' },\n    ],\n    name: 'FailedOp',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: 'opIndex', type: 'uint256' },\n      { internalType: 'string', name: 'reason', type: 'string' },\n      { internalType: 'bytes', name: 'inner', type: 'bytes' },\n    ],\n    name: 'FailedOpWithRevert',\n    type: 'error',\n  },\n  { inputs: [], name: 'InvalidShortString', type: 'error' },\n  {\n    inputs: [{ internalType: 'bytes', name: 'returnData', type: 'bytes' }],\n    name: 'PostOpReverted',\n    type: 'error',\n  },\n  { inputs: [], name: 'ReentrancyGuardReentrantCall', type: 'error' },\n  {\n    inputs: [{ internalType: 'address', name: 'sender', type: 'address' }],\n    name: 'SenderAddressResult',\n    type: 'error',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'aggregator', type: 'address' }],\n    name: 'SignatureValidationFailed',\n    type: 'error',\n  },\n  {\n    inputs: [{ internalType: 'string', name: 'str', type: 'string' }],\n    name: 'StringTooLong',\n    type: 'error',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'factory',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'paymaster',\n        type: 'address',\n      },\n    ],\n    name: 'AccountDeployed',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'BeforeExecution', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'totalDeposit',\n        type: 'uint256',\n      },\n    ],\n    name: 'Deposited',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'EIP712DomainChanged', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'bytes',\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'PostOpRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'aggregator',\n        type: 'address',\n      },\n    ],\n    name: 'SignatureAggregatorChanged',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'totalStaked',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'unstakeDelaySec',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeLocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'withdrawTime',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeUnlocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeWithdrawn',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'paymaster',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n      { indexed: false, internalType: 'bool', name: 'success', type: 'bool' },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'actualGasCost',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'actualGasUsed',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationEvent',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationPrefundTooLow',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'bytes',\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'UserOperationRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'Withdrawn',\n    type: 'event',\n  },\n  {\n    inputs: [\n      { internalType: 'uint32', name: 'unstakeDelaySec', type: 'uint32' },\n    ],\n    name: 'addStake',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'account', type: 'address' }],\n    name: 'balanceOf',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'target', type: 'address' },\n      { internalType: 'bytes', name: 'data', type: 'bytes' },\n    ],\n    name: 'delegateAndRevert',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'account', type: 'address' }],\n    name: 'depositTo',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'eip712Domain',\n    outputs: [\n      { internalType: 'bytes1', name: 'fields', type: 'bytes1' },\n      { internalType: 'string', name: 'name', type: 'string' },\n      { internalType: 'string', name: 'version', type: 'string' },\n      { internalType: 'uint256', name: 'chainId', type: 'uint256' },\n      { internalType: 'address', name: 'verifyingContract', type: 'address' },\n      { internalType: 'bytes32', name: 'salt', type: 'bytes32' },\n      { internalType: 'uint256[]', name: 'extensions', type: 'uint256[]' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'account', type: 'address' }],\n    name: 'getDepositInfo',\n    outputs: [\n      {\n        components: [\n          { internalType: 'uint256', name: 'deposit', type: 'uint256' },\n          { internalType: 'bool', name: 'staked', type: 'bool' },\n          { internalType: 'uint112', name: 'stake', type: 'uint112' },\n          { internalType: 'uint32', name: 'unstakeDelaySec', type: 'uint32' },\n          { internalType: 'uint48', name: 'withdrawTime', type: 'uint48' },\n        ],\n        internalType: 'struct IStakeManager.DepositInfo',\n        name: 'info',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getDomainSeparatorV4',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'sender', type: 'address' },\n      { internalType: 'uint192', name: 'key', type: 'uint192' },\n    ],\n    name: 'getNonce',\n    outputs: [{ internalType: 'uint256', name: 'nonce', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getPackedUserOpTypeHash',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'pure',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'bytes', name: 'initCode', type: 'bytes' }],\n    name: 'getSenderAddress',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: 'address', name: 'sender', type: 'address' },\n          { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n          { internalType: 'bytes', name: 'initCode', type: 'bytes' },\n          { internalType: 'bytes', name: 'callData', type: 'bytes' },\n          {\n            internalType: 'bytes32',\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { internalType: 'bytes32', name: 'gasFees', type: 'bytes32' },\n          { internalType: 'bytes', name: 'paymasterAndData', type: 'bytes' },\n          { internalType: 'bytes', name: 'signature', type: 'bytes' },\n        ],\n        internalType: 'struct PackedUserOperation',\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'getUserOpHash',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              { internalType: 'address', name: 'sender', type: 'address' },\n              { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n              { internalType: 'bytes', name: 'initCode', type: 'bytes' },\n              { internalType: 'bytes', name: 'callData', type: 'bytes' },\n              {\n                internalType: 'bytes32',\n                name: 'accountGasLimits',\n                type: 'bytes32',\n              },\n              {\n                internalType: 'uint256',\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { internalType: 'bytes32', name: 'gasFees', type: 'bytes32' },\n              {\n                internalType: 'bytes',\n                name: 'paymasterAndData',\n                type: 'bytes',\n              },\n              { internalType: 'bytes', name: 'signature', type: 'bytes' },\n            ],\n            internalType: 'struct PackedUserOperation[]',\n            name: 'userOps',\n            type: 'tuple[]',\n          },\n          {\n            internalType: 'contract IAggregator',\n            name: 'aggregator',\n            type: 'address',\n          },\n          { internalType: 'bytes', name: 'signature', type: 'bytes' },\n        ],\n        internalType: 'struct IEntryPoint.UserOpsPerAggregator[]',\n        name: 'opsPerAggregator',\n        type: 'tuple[]',\n      },\n      { internalType: 'address payable', name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleAggregatedOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: 'address', name: 'sender', type: 'address' },\n          { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n          { internalType: 'bytes', name: 'initCode', type: 'bytes' },\n          { internalType: 'bytes', name: 'callData', type: 'bytes' },\n          {\n            internalType: 'bytes32',\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { internalType: 'bytes32', name: 'gasFees', type: 'bytes32' },\n          { internalType: 'bytes', name: 'paymasterAndData', type: 'bytes' },\n          { internalType: 'bytes', name: 'signature', type: 'bytes' },\n        ],\n        internalType: 'struct PackedUserOperation[]',\n        name: 'ops',\n        type: 'tuple[]',\n      },\n      { internalType: 'address payable', name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'uint192', name: 'key', type: 'uint192' }],\n    name: 'incrementNonce',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'bytes', name: 'callData', type: 'bytes' },\n      {\n        components: [\n          {\n            components: [\n              { internalType: 'address', name: 'sender', type: 'address' },\n              { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n              {\n                internalType: 'uint256',\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'paymasterVerificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'paymasterPostOpGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { internalType: 'address', name: 'paymaster', type: 'address' },\n              {\n                internalType: 'uint256',\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n            ],\n            internalType: 'struct EntryPoint.MemoryUserOp',\n            name: 'mUserOp',\n            type: 'tuple',\n          },\n          { internalType: 'bytes32', name: 'userOpHash', type: 'bytes32' },\n          { internalType: 'uint256', name: 'prefund', type: 'uint256' },\n          { internalType: 'uint256', name: 'contextOffset', type: 'uint256' },\n          { internalType: 'uint256', name: 'preOpGas', type: 'uint256' },\n        ],\n        internalType: 'struct EntryPoint.UserOpInfo',\n        name: 'opInfo',\n        type: 'tuple',\n      },\n      { internalType: 'bytes', name: 'context', type: 'bytes' },\n    ],\n    name: 'innerHandleOp',\n    outputs: [\n      { internalType: 'uint256', name: 'actualGasCost', type: 'uint256' },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: '', type: 'address' },\n      { internalType: 'uint192', name: '', type: 'uint192' },\n    ],\n    name: 'nonceSequenceNumber',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'senderCreator',\n    outputs: [\n      { internalType: 'contract ISenderCreator', name: '', type: 'address' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'bytes4', name: 'interfaceId', type: 'bytes4' }],\n    name: 'supportsInterface',\n    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'unlockStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address payable',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n    ],\n    name: 'withdrawStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address payable',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      { internalType: 'uint256', name: 'withdrawAmount', type: 'uint256' },\n    ],\n    name: 'withdrawTo',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n","const reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...a) => api.dispatch(...a), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api) return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === undefined) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extensionConnector) {\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording) return r;\n    const action = nameOrAction === undefined ? { type: anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === undefined) {\n      connection == null ? undefined : connection.send(action, get());\n      return r;\n    }\n    connection == null ? undefined : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? undefined : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? undefined : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...a) => {\n      if ((import.meta.env ? import.meta.env.MODE : undefined) !== \"production\" && a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...a);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === undefined) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format.\n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === undefined || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools) return;\n            if (typeof api.dispatch !== \"function\") return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === undefined) {\n              return connection == null ? undefined : connection.init(api.getState());\n            }\n            return connection == null ? undefined : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === undefined) {\n              connection == null ? undefined : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? undefined : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === undefined) {\n                setStateFromDevtools(state);\n                connection == null ? undefined : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? undefined : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === undefined) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? undefined : _a.state;\n            if (!lastComputedState) return;\n            if (store === undefined) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? undefined : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, f) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== undefined) f(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? undefined : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? undefined : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nconst combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? undefined : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(\n      name,\n      JSON.stringify(newValue, options == null ? undefined : options.replacer)\n    ),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst persistImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  api.getInitialState = () => configResult;\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage) return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? undefined : _b.call(options, (_a = get()) != null ? _a : configResult)) || undefined;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            const migration = options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n            if (migration instanceof Promise) {\n              return migration.then((result) => [true, result]);\n            }\n            return [true, migration];\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return [false, deserializedStorageValue.state];\n        }\n      }\n      return [false, undefined];\n    }).then((migrationResult) => {\n      var _a2;\n      const [migrated, migratedState] = migrationResult;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      if (migrated) {\n        return setItem();\n      }\n    }).then(() => {\n      postRehydrationCallback == null ? undefined : postRehydrationCallback(stateFromStorage, undefined);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? undefined : postRehydrationCallback(undefined, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? undefined : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persist = persistImpl;\n\nexport { combine, createJSONStorage, devtools, persist, redux, subscribeWithSelector };\n","import type { Address } from 'abitype'\nimport { BaseError } from '../../errors/base.js'\nimport type { Hex } from '../../types/misc.js'\n\nexport type AccountNotDeployedErrorType = AccountNotDeployedError & {\n  name: 'AccountNotDeployedError'\n}\nexport class AccountNotDeployedError extends BaseError {\n  static message = /aa20/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Smart Account is not deployed.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- No `factory`/`factoryData` or `initCode` properties are provided for Smart Account deployment.',\n        '- An incorrect `sender` address is provided.',\n      ],\n      name: 'AccountNotDeployedError',\n    })\n  }\n}\n\nexport type ExecutionRevertedErrorType = ExecutionRevertedError & {\n  code: -32521\n  name: 'ExecutionRevertedError'\n}\nexport class ExecutionRevertedError extends BaseError {\n  static code = -32521\n  static message = /execution reverted/\n\n  data?: { revertData?: Hex } | undefined\n\n  constructor({\n    cause,\n    data,\n    message,\n  }: {\n    cause?: BaseError | undefined\n    data?: { revertData?: Hex } | undefined\n    message?: string | undefined\n  } = {}) {\n    const reason = message\n      ?.replace('execution reverted: ', '')\n      ?.replace('execution reverted', '')\n    super(\n      `Execution reverted ${\n        reason ? `with reason: ${reason}` : 'for an unknown reason'\n      }.`,\n      {\n        cause,\n        name: 'ExecutionRevertedError',\n      },\n    )\n\n    this.data = data\n  }\n}\n\nexport type FailedToSendToBeneficiaryErrorType =\n  FailedToSendToBeneficiaryError & {\n    name: 'FailedToSendToBeneficiaryError'\n  }\nexport class FailedToSendToBeneficiaryError extends BaseError {\n  static message = /aa91/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Failed to send funds to beneficiary.', {\n      cause,\n      name: 'FailedToSendToBeneficiaryError',\n    })\n  }\n}\n\nexport type GasValuesOverflowErrorType = GasValuesOverflowError & {\n  name: 'GasValuesOverflowError'\n}\nexport class GasValuesOverflowError extends BaseError {\n  static message = /aa94/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Gas value overflowed.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- one of the gas values exceeded 2**120 (uint120)',\n      ].filter(Boolean) as string[],\n      name: 'GasValuesOverflowError',\n    })\n  }\n}\n\nexport type HandleOpsOutOfGasErrorType = HandleOpsOutOfGasError & {\n  name: 'HandleOpsOutOfGasError'\n}\nexport class HandleOpsOutOfGasError extends BaseError {\n  static message = /aa95/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super(\n      'The `handleOps` function was called by the Bundler with a gas limit too low.',\n      {\n        cause,\n        name: 'HandleOpsOutOfGasError',\n      },\n    )\n  }\n}\n\nexport type InitCodeFailedErrorType = InitCodeFailedError & {\n  name: 'InitCodeFailedError'\n}\nexport class InitCodeFailedError extends BaseError {\n  static message = /aa13/\n  constructor({\n    cause,\n    factory,\n    factoryData,\n    initCode,\n  }: {\n    cause?: BaseError | undefined\n    factory?: Address | undefined\n    factoryData?: Hex | undefined\n    initCode?: Hex | undefined\n  }) {\n    super('Failed to simulate deployment for Smart Account.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- Invalid `factory`/`factoryData` or `initCode` properties are present',\n        '- Smart Account deployment execution ran out of gas (low `verificationGasLimit` value)',\n        '- Smart Account deployment execution reverted with an error\\n',\n        factory && `factory: ${factory}`,\n        factoryData && `factoryData: ${factoryData}`,\n        initCode && `initCode: ${initCode}`,\n      ].filter(Boolean) as string[],\n      name: 'InitCodeFailedError',\n    })\n  }\n}\n\nexport type InitCodeMustCreateSenderErrorType =\n  InitCodeMustCreateSenderError & {\n    name: 'InitCodeMustCreateSenderError'\n  }\nexport class InitCodeMustCreateSenderError extends BaseError {\n  static message = /aa15/\n  constructor({\n    cause,\n    factory,\n    factoryData,\n    initCode,\n  }: {\n    cause?: BaseError | undefined\n    factory?: Address | undefined\n    factoryData?: Hex | undefined\n    initCode?: Hex | undefined\n  }) {\n    super(\n      'Smart Account initialization implementation did not create an account.',\n      {\n        cause,\n        metaMessages: [\n          'This could arise when:',\n          '- `factory`/`factoryData` or `initCode` properties are invalid',\n          '- Smart Account initialization implementation is incorrect\\n',\n          factory && `factory: ${factory}`,\n          factoryData && `factoryData: ${factoryData}`,\n          initCode && `initCode: ${initCode}`,\n        ].filter(Boolean) as string[],\n        name: 'InitCodeMustCreateSenderError',\n      },\n    )\n  }\n}\n\nexport type InitCodeMustReturnSenderErrorType =\n  InitCodeMustReturnSenderError & {\n    name: 'InitCodeMustReturnSenderError'\n  }\nexport class InitCodeMustReturnSenderError extends BaseError {\n  static message = /aa14/\n  constructor({\n    cause,\n    factory,\n    factoryData,\n    initCode,\n    sender,\n  }: {\n    cause?: BaseError | undefined\n    factory?: Address | undefined\n    factoryData?: Hex | undefined\n    initCode?: Hex | undefined\n    sender?: Address | undefined\n  }) {\n    super(\n      'Smart Account initialization implementation does not return the expected sender.',\n      {\n        cause,\n        metaMessages: [\n          'This could arise when:',\n          'Smart Account initialization implementation does not return a sender address\\n',\n          factory && `factory: ${factory}`,\n          factoryData && `factoryData: ${factoryData}`,\n          initCode && `initCode: ${initCode}`,\n          sender && `sender: ${sender}`,\n        ].filter(Boolean) as string[],\n        name: 'InitCodeMustReturnSenderError',\n      },\n    )\n  }\n}\n\nexport type InsufficientPrefundErrorType = InsufficientPrefundError & {\n  name: 'InsufficientPrefundError'\n}\nexport class InsufficientPrefundError extends BaseError {\n  static message = /aa21/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super(\n      'Smart Account does not have sufficient funds to execute the User Operation.',\n      {\n        cause,\n        metaMessages: [\n          'This could arise when:',\n          '- the Smart Account does not have sufficient funds to cover the required prefund, or',\n          '- a Paymaster was not provided',\n        ].filter(Boolean) as string[],\n        name: 'InsufficientPrefundError',\n      },\n    )\n  }\n}\n\nexport type InternalCallOnlyErrorType = InternalCallOnlyError & {\n  name: 'InternalCallOnlyError'\n}\nexport class InternalCallOnlyError extends BaseError {\n  static message = /aa92/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Bundler attempted to call an invalid function on the EntryPoint.', {\n      cause,\n      name: 'InternalCallOnlyError',\n    })\n  }\n}\n\nexport type InvalidAggregatorErrorType = InvalidAggregatorError & {\n  name: 'InvalidAggregatorError'\n}\nexport class InvalidAggregatorError extends BaseError {\n  static message = /aa96/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super(\n      'Bundler used an invalid aggregator for handling aggregated User Operations.',\n      {\n        cause,\n        name: 'InvalidAggregatorError',\n      },\n    )\n  }\n}\n\nexport type InvalidAccountNonceErrorType = InvalidAccountNonceError & {\n  name: 'InvalidAccountNonceError'\n}\nexport class InvalidAccountNonceError extends BaseError {\n  static message = /aa25/\n  constructor({\n    cause,\n    nonce,\n  }: {\n    cause?: BaseError | undefined\n    nonce?: bigint | undefined\n  }) {\n    super('Invalid Smart Account nonce used for User Operation.', {\n      cause,\n      metaMessages: [nonce && `nonce: ${nonce}`].filter(Boolean) as string[],\n      name: 'InvalidAccountNonceError',\n    })\n  }\n}\n\nexport type InvalidBeneficiaryErrorType = InvalidBeneficiaryError & {\n  name: 'InvalidBeneficiaryError'\n}\nexport class InvalidBeneficiaryError extends BaseError {\n  static message = /aa90/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Bundler has not set a beneficiary address.', {\n      cause,\n      name: 'InvalidBeneficiaryError',\n    })\n  }\n}\n\nexport type InvalidFieldsErrorType = InvalidFieldsError & {\n  name: 'InvalidFieldsError'\n}\nexport class InvalidFieldsError extends BaseError {\n  static code = -32602\n\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Invalid fields set on User Operation.', {\n      cause,\n      name: 'InvalidFieldsError',\n    })\n  }\n}\n\nexport type InvalidPaymasterAndDataErrorType = InvalidPaymasterAndDataError & {\n  name: 'InvalidPaymasterAndDataError'\n}\nexport class InvalidPaymasterAndDataError extends BaseError {\n  static message = /aa93/\n  constructor({\n    cause,\n    paymasterAndData,\n  }: {\n    cause?: BaseError | undefined\n    paymasterAndData?: Hex | undefined\n  }) {\n    super('Paymaster properties provided are invalid.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `paymasterAndData` property is of an incorrect length\\n',\n        paymasterAndData && `paymasterAndData: ${paymasterAndData}`,\n      ].filter(Boolean) as string[],\n      name: 'InvalidPaymasterAndDataError',\n    })\n  }\n}\n\nexport type PaymasterDepositTooLowErrorType = PaymasterDepositTooLowError & {\n  code: -32508\n  name: 'PaymasterDepositTooLowError'\n}\nexport class PaymasterDepositTooLowError extends BaseError {\n  static code = -32508\n  static message = /aa31/\n\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Paymaster deposit for the User Operation is too low.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the Paymaster has deposited less than the expected amount via the `deposit` function',\n      ].filter(Boolean) as string[],\n      name: 'PaymasterDepositTooLowError',\n    })\n  }\n}\n\nexport type PaymasterFunctionRevertedErrorType =\n  PaymasterFunctionRevertedError & {\n    name: 'PaymasterFunctionRevertedError'\n  }\nexport class PaymasterFunctionRevertedError extends BaseError {\n  static message = /aa33/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('The `validatePaymasterUserOp` function on the Paymaster reverted.', {\n      cause,\n      name: 'PaymasterFunctionRevertedError',\n    })\n  }\n}\n\nexport type PaymasterNotDeployedErrorType = PaymasterNotDeployedError & {\n  name: 'PaymasterNotDeployedError'\n}\nexport class PaymasterNotDeployedError extends BaseError {\n  static message = /aa30/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('The Paymaster contract has not been deployed.', {\n      cause,\n      name: 'PaymasterNotDeployedError',\n    })\n  }\n}\n\nexport type PaymasterRateLimitErrorType = PaymasterRateLimitError & {\n  code: -32504\n  name: 'PaymasterRateLimitError'\n}\nexport class PaymasterRateLimitError extends BaseError {\n  static code = -32504\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation rejected because paymaster (or signature aggregator) is throttled/banned.',\n      {\n        cause,\n        name: 'PaymasterRateLimitError',\n      },\n    )\n  }\n}\n\nexport type PaymasterStakeTooLowErrorType = PaymasterStakeTooLowError & {\n  code: -32505\n  name: 'PaymasterStakeTooLowError'\n}\nexport class PaymasterStakeTooLowError extends BaseError {\n  static code = -32505\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation rejected because paymaster (or signature aggregator) is throttled/banned.',\n      {\n        cause,\n        name: 'PaymasterStakeTooLowError',\n      },\n    )\n  }\n}\n\nexport type PaymasterPostOpFunctionRevertedErrorType =\n  PaymasterPostOpFunctionRevertedError & {\n    name: 'PaymasterPostOpFunctionRevertedError'\n  }\nexport class PaymasterPostOpFunctionRevertedError extends BaseError {\n  static message = /aa50/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Paymaster `postOp` function reverted.', {\n      cause,\n      name: 'PaymasterPostOpFunctionRevertedError',\n    })\n  }\n}\n\nexport type SenderAlreadyConstructedErrorType =\n  SenderAlreadyConstructedError & {\n    name: 'SenderAlreadyConstructedError'\n  }\nexport class SenderAlreadyConstructedError extends BaseError {\n  static message = /aa10/\n  constructor({\n    cause,\n    factory,\n    factoryData,\n    initCode,\n  }: {\n    cause?: BaseError | undefined\n    factory?: Address | undefined\n    factoryData?: Hex | undefined\n    initCode?: Hex | undefined\n  }) {\n    super('Smart Account has already been deployed.', {\n      cause,\n      metaMessages: [\n        'Remove the following properties and try again:',\n        factory && '`factory`',\n        factoryData && '`factoryData`',\n        initCode && '`initCode`',\n      ].filter(Boolean) as string[],\n      name: 'SenderAlreadyConstructedError',\n    })\n  }\n}\n\nexport type SignatureCheckFailedErrorType = SignatureCheckFailedError & {\n  code: -32507\n  name: 'SignatureCheckFailedError'\n}\nexport class SignatureCheckFailedError extends BaseError {\n  static code = -32507\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation rejected because account signature check failed (or paymaster signature, if the paymaster uses its data as signature).',\n      {\n        cause,\n        name: 'SignatureCheckFailedError',\n      },\n    )\n  }\n}\n\nexport type SmartAccountFunctionRevertedErrorType =\n  SmartAccountFunctionRevertedError & {\n    name: 'SmartAccountFunctionRevertedError'\n  }\nexport class SmartAccountFunctionRevertedError extends BaseError {\n  static message = /aa23/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('The `validateUserOp` function on the Smart Account reverted.', {\n      cause,\n      name: 'SmartAccountFunctionRevertedError',\n    })\n  }\n}\n\nexport type UnsupportedSignatureAggregatorErrorType =\n  UnsupportedSignatureAggregatorError & {\n    code: -32506\n    name: 'UnsupportedSignatureAggregatorError'\n  }\nexport class UnsupportedSignatureAggregatorError extends BaseError {\n  static code = -32506\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation rejected because account specified unsupported signature aggregator.',\n      {\n        cause,\n        name: 'UnsupportedSignatureAggregatorError',\n      },\n    )\n  }\n}\n\nexport type UserOperationExpiredErrorType = UserOperationExpiredError & {\n  name: 'UserOperationExpiredError'\n}\nexport class UserOperationExpiredError extends BaseError {\n  static message = /aa22/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('User Operation expired.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `validAfter` or `validUntil` values returned from `validateUserOp` on the Smart Account are not satisfied',\n      ].filter(Boolean) as string[],\n      name: 'UserOperationExpiredError',\n    })\n  }\n}\n\nexport type UserOperationPaymasterExpiredErrorType =\n  UserOperationPaymasterExpiredError & {\n    name: 'UserOperationPaymasterExpiredError'\n  }\nexport class UserOperationPaymasterExpiredError extends BaseError {\n  static message = /aa32/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Paymaster for User Operation expired.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `validAfter` or `validUntil` values returned from `validatePaymasterUserOp` on the Paymaster are not satisfied',\n      ].filter(Boolean) as string[],\n      name: 'UserOperationPaymasterExpiredError',\n    })\n  }\n}\n\nexport type UserOperationSignatureErrorType = UserOperationSignatureError & {\n  name: 'UserOperationSignatureError'\n}\nexport class UserOperationSignatureError extends BaseError {\n  static message = /aa24/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Signature provided for the User Operation is invalid.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `signature` for the User Operation is incorrectly computed, and unable to be verified by the Smart Account',\n      ].filter(Boolean) as string[],\n      name: 'UserOperationSignatureError',\n    })\n  }\n}\n\nexport type UserOperationPaymasterSignatureErrorType =\n  UserOperationPaymasterSignatureError & {\n    name: 'UserOperationPaymasterSignatureError'\n  }\nexport class UserOperationPaymasterSignatureError extends BaseError {\n  static message = /aa34/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Signature provided for the User Operation is invalid.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `signature` for the User Operation is incorrectly computed, and unable to be verified by the Paymaster',\n      ].filter(Boolean) as string[],\n      name: 'UserOperationPaymasterSignatureError',\n    })\n  }\n}\n\nexport type UserOperationRejectedByEntryPointErrorType =\n  UserOperationRejectedByEntryPointError & {\n    code: -32500\n    name: 'UserOperationRejectedByEntryPointError'\n  }\nexport class UserOperationRejectedByEntryPointError extends BaseError {\n  static code = -32500\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      \"User Operation rejected by EntryPoint's `simulateValidation` during account creation or validation.\",\n      {\n        cause,\n        name: 'UserOperationRejectedByEntryPointError',\n      },\n    )\n  }\n}\n\nexport type UserOperationRejectedByPaymasterErrorType =\n  UserOperationRejectedByPaymasterError & {\n    code: -32501\n    name: 'UserOperationRejectedByPaymasterError'\n  }\nexport class UserOperationRejectedByPaymasterError extends BaseError {\n  static code = -32501\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\"User Operation rejected by Paymaster's `validatePaymasterUserOp`.\", {\n      cause,\n      name: 'UserOperationRejectedByPaymasterError',\n    })\n  }\n}\n\nexport type UserOperationRejectedByOpCodeErrorType =\n  UserOperationRejectedByOpCodeError & {\n    code: -32502\n    name: 'UserOperationRejectedByOpCodeError'\n  }\nexport class UserOperationRejectedByOpCodeError extends BaseError {\n  static code = -32502\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super('User Operation rejected with op code validation error.', {\n      cause,\n      name: 'UserOperationRejectedByOpCodeError',\n    })\n  }\n}\n\nexport type UserOperationOutOfTimeRangeErrorType =\n  UserOperationOutOfTimeRangeError & {\n    code: -32503\n    name: 'UserOperationOutOfTimeRangeError'\n  }\nexport class UserOperationOutOfTimeRangeError extends BaseError {\n  static code = -32503\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation out of time-range: either wallet or paymaster returned a time-range, and it is already expired (or will expire soon).',\n      {\n        cause,\n        name: 'UserOperationOutOfTimeRangeError',\n      },\n    )\n  }\n}\n\nexport type UnknownBundlerErrorType = UnknownBundlerError & {\n  name: 'UnknownBundlerError'\n}\nexport class UnknownBundlerError extends BaseError {\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      `An error occurred while executing user operation: ${cause?.shortMessage}`,\n      {\n        cause,\n        name: 'UnknownBundlerError',\n      },\n    )\n  }\n}\n\nexport type VerificationGasLimitExceededErrorType =\n  VerificationGasLimitExceededError & {\n    name: 'VerificationGasLimitExceededError'\n  }\nexport class VerificationGasLimitExceededError extends BaseError {\n  static message = /aa40/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('User Operation verification gas limit exceeded.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the gas used for verification exceeded the `verificationGasLimit`',\n      ].filter(Boolean) as string[],\n      name: 'VerificationGasLimitExceededError',\n    })\n  }\n}\n\nexport type VerificationGasLimitTooLowErrorType =\n  VerificationGasLimitTooLowError & {\n    name: 'VerificationGasLimitTooLowError'\n  }\nexport class VerificationGasLimitTooLowError extends BaseError {\n  static message = /aa41/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('User Operation verification gas limit is too low.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `verificationGasLimit` is too low to verify the User Operation',\n      ].filter(Boolean) as string[],\n      name: 'VerificationGasLimitTooLowError',\n    })\n  }\n}\n","import { BaseError } from '../../errors/base.js'\nimport { prettyPrint } from '../../errors/transaction.js'\nimport type { Hash } from '../../types/misc.js'\nimport { formatGwei } from '../../utils/index.js'\nimport type { UserOperation } from '../types/userOperation.js'\n\nexport type UserOperationExecutionErrorType = UserOperationExecutionError & {\n  name: 'UserOperationExecutionError'\n}\nexport class UserOperationExecutionError extends BaseError {\n  override cause: BaseError\n\n  constructor(\n    cause: BaseError,\n    {\n      callData,\n      callGasLimit,\n      docsPath,\n      factory,\n      factoryData,\n      initCode,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      paymaster,\n      paymasterAndData,\n      paymasterData,\n      paymasterPostOpGasLimit,\n      paymasterVerificationGasLimit,\n      preVerificationGas,\n      sender,\n      signature,\n      verificationGasLimit,\n    }: UserOperation & {\n      docsPath?: string | undefined\n    },\n  ) {\n    const prettyArgs = prettyPrint({\n      callData,\n      callGasLimit,\n      factory,\n      factoryData,\n      initCode,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n      paymaster,\n      paymasterAndData,\n      paymasterData,\n      paymasterPostOpGasLimit,\n      paymasterVerificationGasLimit,\n      preVerificationGas,\n      sender,\n      signature,\n      verificationGasLimit,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Request Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n      name: 'UserOperationExecutionError',\n    })\n    this.cause = cause\n  }\n}\n\nexport type UserOperationReceiptNotFoundErrorType =\n  UserOperationReceiptNotFoundError & {\n    name: 'UserOperationReceiptNotFoundError'\n  }\nexport class UserOperationReceiptNotFoundError extends BaseError {\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `User Operation receipt with hash \"${hash}\" could not be found. The User Operation may not have been processed yet.`,\n      { name: 'UserOperationReceiptNotFoundError' },\n    )\n  }\n}\n\nexport type UserOperationNotFoundErrorType = UserOperationNotFoundError & {\n  name: 'UserOperationNotFoundError'\n}\nexport class UserOperationNotFoundError extends BaseError {\n  constructor({ hash }: { hash: Hash }) {\n    super(`User Operation with hash \"${hash}\" could not be found.`, {\n      name: 'UserOperationNotFoundError',\n    })\n  }\n}\n\nexport type WaitForUserOperationReceiptTimeoutErrorType =\n  WaitForUserOperationReceiptTimeoutError & {\n    name: 'WaitForUserOperationReceiptTimeoutError'\n  }\nexport class WaitForUserOperationReceiptTimeoutError extends BaseError {\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Timed out while waiting for User Operation with hash \"${hash}\" to be confirmed.`,\n      { name: 'WaitForUserOperationReceiptTimeoutError' },\n    )\n  }\n}\n","import type { BaseError } from '../../../errors/base.js'\nimport type { ExactPartial } from '../../../types/utils.js'\nimport {\n  AccountNotDeployedError,\n  type AccountNotDeployedErrorType,\n  ExecutionRevertedError,\n  type ExecutionRevertedErrorType,\n  FailedToSendToBeneficiaryError,\n  type FailedToSendToBeneficiaryErrorType,\n  GasValuesOverflowError,\n  type GasValuesOverflowErrorType,\n  HandleOpsOutOfGasError,\n  type HandleOpsOutOfGasErrorType,\n  InitCodeFailedError,\n  type InitCodeFailedErrorType,\n  InitCodeMustCreateSenderError,\n  type InitCodeMustCreateSenderErrorType,\n  InitCodeMustReturnSenderError,\n  type InitCodeMustReturnSenderErrorType,\n  InsufficientPrefundError,\n  type InsufficientPrefundErrorType,\n  InternalCallOnlyError,\n  type InternalCallOnlyErrorType,\n  InvalidAccountNonceError,\n  type InvalidAccountNonceErrorType,\n  InvalidAggregatorError,\n  type InvalidAggregatorErrorType,\n  InvalidBeneficiaryError,\n  type InvalidBeneficiaryErrorType,\n  InvalidFieldsError,\n  type InvalidFieldsErrorType,\n  InvalidPaymasterAndDataError,\n  type InvalidPaymasterAndDataErrorType,\n  PaymasterDepositTooLowError,\n  type PaymasterDepositTooLowErrorType,\n  PaymasterFunctionRevertedError,\n  type PaymasterFunctionRevertedErrorType,\n  PaymasterNotDeployedError,\n  type PaymasterNotDeployedErrorType,\n  PaymasterPostOpFunctionRevertedError,\n  type PaymasterPostOpFunctionRevertedErrorType,\n  PaymasterRateLimitError,\n  type PaymasterRateLimitErrorType,\n  PaymasterStakeTooLowError,\n  type PaymasterStakeTooLowErrorType,\n  SenderAlreadyConstructedError,\n  type SenderAlreadyConstructedErrorType,\n  SignatureCheckFailedError,\n  type SignatureCheckFailedErrorType,\n  SmartAccountFunctionRevertedError,\n  type SmartAccountFunctionRevertedErrorType,\n  UnknownBundlerError,\n  type UnknownBundlerErrorType,\n  UnsupportedSignatureAggregatorError,\n  type UnsupportedSignatureAggregatorErrorType,\n  UserOperationExpiredError,\n  type UserOperationExpiredErrorType,\n  UserOperationOutOfTimeRangeError,\n  type UserOperationOutOfTimeRangeErrorType,\n  UserOperationPaymasterExpiredError,\n  type UserOperationPaymasterExpiredErrorType,\n  UserOperationPaymasterSignatureError,\n  type UserOperationPaymasterSignatureErrorType,\n  UserOperationRejectedByEntryPointError,\n  type UserOperationRejectedByEntryPointErrorType,\n  UserOperationRejectedByOpCodeError,\n  type UserOperationRejectedByOpCodeErrorType,\n  UserOperationRejectedByPaymasterError,\n  type UserOperationRejectedByPaymasterErrorType,\n  UserOperationSignatureError,\n  type UserOperationSignatureErrorType,\n  VerificationGasLimitExceededError,\n  type VerificationGasLimitExceededErrorType,\n  VerificationGasLimitTooLowError,\n  type VerificationGasLimitTooLowErrorType,\n} from '../../errors/bundler.js'\nimport type { UserOperation } from '../../types/userOperation.js'\n\nconst bundlerErrors = [\n  ExecutionRevertedError,\n  InvalidFieldsError,\n  PaymasterDepositTooLowError,\n  PaymasterRateLimitError,\n  PaymasterStakeTooLowError,\n  SignatureCheckFailedError,\n  UnsupportedSignatureAggregatorError,\n  UserOperationOutOfTimeRangeError,\n  UserOperationRejectedByEntryPointError,\n  UserOperationRejectedByPaymasterError,\n  UserOperationRejectedByOpCodeError,\n]\n\nexport type GetBundlerErrorParameters = ExactPartial<UserOperation>\n\nexport type GetBundlerErrorReturnType =\n  | AccountNotDeployedErrorType\n  | ExecutionRevertedErrorType\n  | FailedToSendToBeneficiaryErrorType\n  | GasValuesOverflowErrorType\n  | HandleOpsOutOfGasErrorType\n  | InitCodeFailedErrorType\n  | InitCodeMustCreateSenderErrorType\n  | InitCodeMustReturnSenderErrorType\n  | InsufficientPrefundErrorType\n  | InternalCallOnlyErrorType\n  | InvalidAccountNonceErrorType\n  | InvalidAggregatorErrorType\n  | InvalidBeneficiaryErrorType\n  | InvalidFieldsErrorType\n  | InvalidPaymasterAndDataErrorType\n  | PaymasterDepositTooLowErrorType\n  | PaymasterFunctionRevertedErrorType\n  | PaymasterNotDeployedErrorType\n  | PaymasterPostOpFunctionRevertedErrorType\n  | PaymasterRateLimitErrorType\n  | PaymasterStakeTooLowErrorType\n  | SignatureCheckFailedErrorType\n  | SenderAlreadyConstructedErrorType\n  | SmartAccountFunctionRevertedErrorType\n  | UnsupportedSignatureAggregatorErrorType\n  | UserOperationOutOfTimeRangeErrorType\n  | UserOperationRejectedByEntryPointErrorType\n  | UserOperationRejectedByOpCodeErrorType\n  | UserOperationRejectedByPaymasterErrorType\n  | UnknownBundlerErrorType\n  | UserOperationExpiredErrorType\n  | UserOperationPaymasterExpiredErrorType\n  | UserOperationPaymasterSignatureErrorType\n  | UserOperationSignatureErrorType\n  | VerificationGasLimitExceededErrorType\n  | VerificationGasLimitTooLowErrorType\n\nexport function getBundlerError(\n  err: BaseError,\n  args: GetBundlerErrorParameters,\n): GetBundlerErrorReturnType {\n  const message = (err.details || '').toLowerCase()\n\n  if (AccountNotDeployedError.message.test(message))\n    return new AccountNotDeployedError({\n      cause: err,\n    }) as any\n  if (FailedToSendToBeneficiaryError.message.test(message))\n    return new FailedToSendToBeneficiaryError({\n      cause: err,\n    }) as any\n  if (GasValuesOverflowError.message.test(message))\n    return new GasValuesOverflowError({\n      cause: err,\n    }) as any\n  if (HandleOpsOutOfGasError.message.test(message))\n    return new HandleOpsOutOfGasError({\n      cause: err,\n    }) as any\n  if (InitCodeFailedError.message.test(message))\n    return new InitCodeFailedError({\n      cause: err,\n      factory: args.factory,\n      factoryData: args.factoryData,\n      initCode: args.initCode,\n    }) as any\n  if (InitCodeMustCreateSenderError.message.test(message))\n    return new InitCodeMustCreateSenderError({\n      cause: err,\n      factory: args.factory,\n      factoryData: args.factoryData,\n      initCode: args.initCode,\n    }) as any\n  if (InitCodeMustReturnSenderError.message.test(message))\n    return new InitCodeMustReturnSenderError({\n      cause: err,\n      factory: args.factory,\n      factoryData: args.factoryData,\n      initCode: args.initCode,\n      sender: args.sender,\n    }) as any\n  if (InsufficientPrefundError.message.test(message))\n    return new InsufficientPrefundError({\n      cause: err,\n    }) as any\n  if (InternalCallOnlyError.message.test(message))\n    return new InternalCallOnlyError({\n      cause: err,\n    }) as any\n  if (InvalidAccountNonceError.message.test(message))\n    return new InvalidAccountNonceError({\n      cause: err,\n      nonce: args.nonce,\n    }) as any\n  if (InvalidAggregatorError.message.test(message))\n    return new InvalidAggregatorError({\n      cause: err,\n    }) as any\n  if (InvalidBeneficiaryError.message.test(message))\n    return new InvalidBeneficiaryError({\n      cause: err,\n    }) as any\n  if (InvalidPaymasterAndDataError.message.test(message))\n    return new InvalidPaymasterAndDataError({\n      cause: err,\n    }) as any\n  if (PaymasterDepositTooLowError.message.test(message))\n    return new PaymasterDepositTooLowError({\n      cause: err,\n    }) as any\n  if (PaymasterFunctionRevertedError.message.test(message))\n    return new PaymasterFunctionRevertedError({\n      cause: err,\n    }) as any\n  if (PaymasterNotDeployedError.message.test(message))\n    return new PaymasterNotDeployedError({\n      cause: err,\n    }) as any\n  if (PaymasterPostOpFunctionRevertedError.message.test(message))\n    return new PaymasterPostOpFunctionRevertedError({\n      cause: err,\n    }) as any\n  if (SmartAccountFunctionRevertedError.message.test(message))\n    return new SmartAccountFunctionRevertedError({\n      cause: err,\n    }) as any\n  if (SenderAlreadyConstructedError.message.test(message))\n    return new SenderAlreadyConstructedError({\n      cause: err,\n      factory: args.factory,\n      factoryData: args.factoryData,\n      initCode: args.initCode,\n    }) as any\n  if (UserOperationExpiredError.message.test(message))\n    return new UserOperationExpiredError({\n      cause: err,\n    }) as any\n  if (UserOperationPaymasterExpiredError.message.test(message))\n    return new UserOperationPaymasterExpiredError({\n      cause: err,\n    }) as any\n  if (UserOperationPaymasterSignatureError.message.test(message))\n    return new UserOperationPaymasterSignatureError({\n      cause: err,\n    }) as any\n  if (UserOperationSignatureError.message.test(message))\n    return new UserOperationSignatureError({\n      cause: err,\n    }) as any\n  if (VerificationGasLimitExceededError.message.test(message))\n    return new VerificationGasLimitExceededError({\n      cause: err,\n    }) as any\n  if (VerificationGasLimitTooLowError.message.test(message))\n    return new VerificationGasLimitTooLowError({\n      cause: err,\n    }) as any\n\n  const error = err.walk((e) =>\n    bundlerErrors.some((error) => error.code === (e as { code: number }).code),\n  ) as BaseError & { code: number; data: any }\n\n  if (error) {\n    if (error.code === ExecutionRevertedError.code)\n      return new ExecutionRevertedError({\n        cause: err,\n        data: error.data,\n        message: error.details,\n      }) as any\n    if (error.code === InvalidFieldsError.code)\n      return new InvalidFieldsError({\n        cause: err,\n      }) as any\n    if (error.code === PaymasterDepositTooLowError.code)\n      return new PaymasterDepositTooLowError({\n        cause: err,\n      }) as any\n    if (error.code === PaymasterRateLimitError.code)\n      return new PaymasterRateLimitError({\n        cause: err,\n      }) as any\n    if (error.code === PaymasterStakeTooLowError.code)\n      return new PaymasterStakeTooLowError({\n        cause: err,\n      }) as any\n    if (error.code === SignatureCheckFailedError.code)\n      return new SignatureCheckFailedError({\n        cause: err,\n      }) as any\n    if (error.code === UnsupportedSignatureAggregatorError.code)\n      return new UnsupportedSignatureAggregatorError({\n        cause: err,\n      }) as any\n    if (error.code === UserOperationOutOfTimeRangeError.code)\n      return new UserOperationOutOfTimeRangeError({\n        cause: err,\n      }) as any\n    if (error.code === UserOperationRejectedByEntryPointError.code)\n      return new UserOperationRejectedByEntryPointError({\n        cause: err,\n      }) as any\n    if (error.code === UserOperationRejectedByPaymasterError.code)\n      return new UserOperationRejectedByPaymasterError({\n        cause: err,\n      }) as any\n    if (error.code === UserOperationRejectedByOpCodeError.code)\n      return new UserOperationRejectedByOpCodeError({\n        cause: err,\n      }) as any\n  }\n\n  return new UnknownBundlerError({\n    cause: err,\n  }) as any\n}\n","import type { Abi, Address } from 'abitype'\nimport { BaseError } from '../../../errors/base.js'\nimport {\n  ContractFunctionExecutionError,\n  ContractFunctionRevertedError,\n  ContractFunctionZeroDataError,\n} from '../../../errors/contract.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Call } from '../../../types/calls.js'\nimport type { Hex } from '../../../types/misc.js'\nimport { decodeErrorResult } from '../../../utils/abi/decodeErrorResult.js'\nimport type { GetContractErrorReturnType } from '../../../utils/errors/getContractError.js'\nimport { ExecutionRevertedError } from '../../errors/bundler.js'\nimport {\n  UserOperationExecutionError,\n  type UserOperationExecutionErrorType,\n} from '../../errors/userOperation.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport {\n  type GetBundlerErrorParameters,\n  getBundlerError,\n} from './getBundlerError.js'\n\ntype GetNodeErrorReturnType = ErrorType\n\nexport type GetUserOperationErrorParameters = UserOperation & {\n  calls?: readonly unknown[] | undefined\n  docsPath?: string | undefined\n}\n\nexport type GetUserOperationErrorReturnType<cause = ErrorType> = Omit<\n  UserOperationExecutionErrorType,\n  'cause'\n> & { cause: cause | GetNodeErrorReturnType }\n\nexport type GetUserOperationErrorErrorType = ErrorType\n\nexport function getUserOperationError<err extends ErrorType<string>>(\n  err: err,\n  { calls, docsPath, ...args }: GetUserOperationErrorParameters,\n): GetUserOperationErrorReturnType<err> {\n  const cause = (() => {\n    const cause = getBundlerError(\n      err as {} as BaseError,\n      args as GetBundlerErrorParameters,\n    )\n    if (calls && cause instanceof ExecutionRevertedError) {\n      const revertData = getRevertData(cause)\n      const contractCalls = calls?.filter(\n        (call: any) => call.abi,\n      ) as readonly Call[]\n      if (revertData && contractCalls.length > 0)\n        return getContractError({ calls: contractCalls, revertData })\n    }\n    return cause\n  })()\n  return new UserOperationExecutionError(cause, {\n    docsPath,\n    ...args,\n  }) as GetUserOperationErrorReturnType<err>\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n\nfunction getRevertData(error: BaseError) {\n  let revertData: Hex | undefined\n  error.walk((e) => {\n    const error = e as any\n    if (\n      typeof error.data === 'string' ||\n      typeof error.data?.revertData === 'string' ||\n      (!(error instanceof BaseError) && typeof error.message === 'string')\n    ) {\n      const match = (\n        error.data?.revertData ||\n        error.data ||\n        error.message\n      ).match?.(/(0x[A-Za-z0-9]*)/)\n      if (match) {\n        revertData = match[1]\n        return true\n      }\n    }\n    return false\n  })\n  return revertData\n}\n\nfunction getContractError(parameters: {\n  calls: readonly Call[]\n  revertData: Hex\n}) {\n  const { calls, revertData } = parameters\n\n  const { abi, functionName, args, to } = (() => {\n    const contractCalls = calls?.filter((call) =>\n      Boolean(call.abi),\n    ) as readonly Call[]\n\n    if (contractCalls.length === 1) return contractCalls[0]\n\n    const compatContractCalls = contractCalls.filter((call) => {\n      try {\n        return Boolean(\n          decodeErrorResult({\n            abi: call.abi,\n            data: revertData,\n          }),\n        )\n      } catch {\n        return false\n      }\n    })\n    if (compatContractCalls.length === 1) return compatContractCalls[0]\n\n    return {\n      abi: [],\n      functionName: contractCalls.reduce(\n        (acc, call) => `${acc ? `${acc} | ` : ''}${call.functionName}`,\n        '',\n      ),\n      args: undefined,\n      to: undefined,\n    }\n  })() as {\n    abi: Abi\n    functionName: string\n    args: unknown[]\n    to: Address\n  }\n\n  const cause = (() => {\n    if (revertData === '0x')\n      return new ContractFunctionZeroDataError({ functionName })\n    return new ContractFunctionRevertedError({\n      abi,\n      data: revertData,\n      functionName,\n    })\n  })()\n  return new ContractFunctionExecutionError(cause as BaseError, {\n    abi,\n    args,\n    contractAddress: to,\n    functionName,\n  }) as GetContractErrorReturnType\n}\n","import type { ErrorType } from '../../../errors/utils.js'\nimport type { SignedAuthorization } from '../../../types/authorization.js'\nimport type { ExactPartial } from '../../../types/utils.js'\nimport { numberToHex } from '../../../utils/encoding/toHex.js'\nimport { pad } from '../../../utils/index.js'\nimport type { RpcUserOperation } from '../../types/rpc.js'\nimport type { UserOperation } from '../../types/userOperation.js'\n\nexport type FormatUserOperationRequestErrorType = ErrorType\n\nexport function formatUserOperationRequest(\n  request: ExactPartial<UserOperation>,\n) {\n  const rpcRequest = {} as RpcUserOperation\n\n  if (typeof request.callData !== 'undefined')\n    rpcRequest.callData = request.callData\n  if (typeof request.callGasLimit !== 'undefined')\n    rpcRequest.callGasLimit = numberToHex(request.callGasLimit)\n  if (typeof request.factory !== 'undefined')\n    rpcRequest.factory = request.factory\n  if (typeof request.factoryData !== 'undefined')\n    rpcRequest.factoryData = request.factoryData\n  if (typeof request.initCode !== 'undefined')\n    rpcRequest.initCode = request.initCode\n  if (typeof request.maxFeePerGas !== 'undefined')\n    rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas)\n  if (typeof request.maxPriorityFeePerGas !== 'undefined')\n    rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas)\n  if (typeof request.nonce !== 'undefined')\n    rpcRequest.nonce = numberToHex(request.nonce)\n  if (typeof request.paymaster !== 'undefined')\n    rpcRequest.paymaster = request.paymaster\n  if (typeof request.paymasterAndData !== 'undefined')\n    rpcRequest.paymasterAndData = request.paymasterAndData || '0x'\n  if (typeof request.paymasterData !== 'undefined')\n    rpcRequest.paymasterData = request.paymasterData\n  if (typeof request.paymasterPostOpGasLimit !== 'undefined')\n    rpcRequest.paymasterPostOpGasLimit = numberToHex(\n      request.paymasterPostOpGasLimit,\n    )\n  if (typeof request.paymasterVerificationGasLimit !== 'undefined')\n    rpcRequest.paymasterVerificationGasLimit = numberToHex(\n      request.paymasterVerificationGasLimit,\n    )\n  if (typeof request.preVerificationGas !== 'undefined')\n    rpcRequest.preVerificationGas = numberToHex(request.preVerificationGas)\n  if (typeof request.sender !== 'undefined') rpcRequest.sender = request.sender\n  if (typeof request.signature !== 'undefined')\n    rpcRequest.signature = request.signature\n  if (typeof request.verificationGasLimit !== 'undefined')\n    rpcRequest.verificationGasLimit = numberToHex(request.verificationGasLimit)\n  if (typeof request.authorization !== 'undefined')\n    rpcRequest.eip7702Auth = formatAuthorization(request.authorization)\n\n  return rpcRequest\n}\n\nfunction formatAuthorization(authorization: SignedAuthorization) {\n  return {\n    address: authorization.address,\n    chainId: numberToHex(authorization.chainId),\n    nonce: numberToHex(authorization.nonce),\n    r: authorization.r\n      ? numberToHex(BigInt(authorization.r), { size: 32 })\n      : pad('0x', { size: 32 }),\n    s: authorization.s\n      ? numberToHex(BigInt(authorization.s), { size: 32 })\n      : pad('0x', { size: 32 }),\n    yParity: authorization.yParity\n      ? numberToHex(authorization.yParity, { size: 1 })\n      : pad('0x', { size: 32 }),\n  }\n}\n","import type { Address } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { OneOf, PartialBy, Prettify } from '../../../types/utils.js'\nimport { hexToBigInt } from '../../../utils/encoding/fromHex.js'\nimport { numberToHex } from '../../../utils/encoding/toHex.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from '../../utils/formatters/userOperationRequest.js'\n\nexport type GetPaymasterDataParameters = OneOf<\n  | PartialBy<\n      Pick<\n        UserOperation<'0.6'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'initCode'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'initCode'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n  | PartialBy<\n      Pick<\n        UserOperation<'0.7'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'factory'\n        | 'factoryData'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n        | 'paymasterPostOpGasLimit'\n        | 'paymasterVerificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'factory'\n      | 'factoryData'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n  | PartialBy<\n      Pick<\n        UserOperation<'0.8'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'factory'\n        | 'factoryData'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n        | 'paymasterPostOpGasLimit'\n        | 'paymasterVerificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'factory'\n      | 'factoryData'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n> & {\n  context?: unknown | undefined\n  chainId: number\n  entryPointAddress: Address\n}\n\nexport type GetPaymasterDataReturnType = Prettify<\n  OneOf<\n    | { paymasterAndData: Hex }\n    | {\n        paymaster: Address\n        paymasterData: Hex\n        paymasterPostOpGasLimit?: bigint | undefined\n        paymasterVerificationGasLimit?: bigint | undefined\n      }\n  >\n>\n\nexport type GetPaymasterDataErrorType =\n  | FormatUserOperationRequestErrorType\n  | ErrorType\n\n/**\n * Retrieves paymaster-related User Operation properties to be used for sending the User Operation.\n *\n * - Docs: https://viem.sh/account-abstraction/actions/paymaster/getPaymasterData\n *\n * @param client - Client to use\n * @param parameters - {@link GetPaymasterDataParameters}\n * @returns Paymaster-related User Operation properties. {@link GetPaymasterDataReturnType}\n *\n * @example\n * import { http } from 'viem'\n * import { createPaymasterClient, getPaymasterData } from 'viem/account-abstraction'\n *\n * const paymasterClient = createPaymasterClient({\n *   transport: http('https://...'),\n * })\n *\n * const userOperation = { ... }\n *\n * const values = await getPaymasterData(paymasterClient, {\n *   chainId: 1,\n *   entryPointAddress: '0x...',\n *   ...userOperation,\n * })\n */\nexport async function getPaymasterData(\n  client: Client<Transport>,\n  parameters: GetPaymasterDataParameters,\n): Promise<GetPaymasterDataReturnType> {\n  const { chainId, entryPointAddress, context, ...userOperation } = parameters\n  const request = formatUserOperationRequest(userOperation)\n  const { paymasterPostOpGasLimit, paymasterVerificationGasLimit, ...rest } =\n    await client.request({\n      method: 'pm_getPaymasterData',\n      params: [\n        {\n          ...request,\n          callGasLimit: request.callGasLimit ?? '0x0',\n          verificationGasLimit: request.verificationGasLimit ?? '0x0',\n          preVerificationGas: request.preVerificationGas ?? '0x0',\n        },\n        entryPointAddress,\n        numberToHex(chainId),\n        context,\n      ],\n    })\n  return {\n    ...rest,\n    ...(paymasterPostOpGasLimit && {\n      paymasterPostOpGasLimit: hexToBigInt(paymasterPostOpGasLimit),\n    }),\n    ...(paymasterVerificationGasLimit && {\n      paymasterVerificationGasLimit: hexToBigInt(paymasterVerificationGasLimit),\n    }),\n  } as unknown as GetPaymasterDataReturnType\n}\n","import type { Address } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { OneOf, PartialBy, Prettify } from '../../../types/utils.js'\nimport { hexToBigInt } from '../../../utils/encoding/fromHex.js'\nimport { numberToHex } from '../../../utils/encoding/toHex.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from '../../utils/formatters/userOperationRequest.js'\n\nexport type GetPaymasterStubDataParameters = OneOf<\n  | PartialBy<\n      Pick<\n        UserOperation<'0.6'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'initCode'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'initCode'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n  | PartialBy<\n      Pick<\n        UserOperation<'0.7'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'factory'\n        | 'factoryData'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'factory'\n      | 'factoryData'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n> & {\n  context?: unknown | undefined\n  chainId: number\n  entryPointAddress: Address\n}\n\nexport type GetPaymasterStubDataReturnType = Prettify<\n  OneOf<\n    | { paymasterAndData: Hex }\n    | {\n        paymaster: Address\n        paymasterData: Hex\n        paymasterVerificationGasLimit?: bigint | undefined\n        paymasterPostOpGasLimit: bigint\n      }\n  > & {\n    sponsor?: { name: string; icon?: string | undefined } | undefined\n    isFinal?: boolean | undefined\n  }\n>\n\nexport type GetPaymasterStubDataErrorType =\n  | FormatUserOperationRequestErrorType\n  | ErrorType\n\n/**\n * Retrieves paymaster-related User Operation properties to be used for gas estimation.\n *\n * - Docs: https://viem.sh/account-abstraction/actions/paymaster/getPaymasterStubData\n *\n * @param client - Client to use\n * @param parameters - {@link GetPaymasterStubDataParameters}\n * @returns Paymaster-related User Operation properties. {@link GetPaymasterStubDataReturnType}\n *\n * @example\n * import { http } from 'viem'\n * import { createPaymasterClient, getPaymasterStubData } from 'viem/account-abstraction'\n *\n * const paymasterClient = createPaymasterClient({\n *   transport: http('https://...'),\n * })\n *\n * const userOperation = { ... }\n *\n * const values = await getPaymasterStubData(paymasterClient, {\n *   chainId: 1,\n *   entryPointAddress: '0x...',\n *   ...userOperation,\n * })\n */\nexport async function getPaymasterStubData(\n  client: Client<Transport>,\n  parameters: GetPaymasterStubDataParameters,\n): Promise<GetPaymasterStubDataReturnType> {\n  const { chainId, entryPointAddress, context, ...userOperation } = parameters\n  const request = formatUserOperationRequest(userOperation)\n  const { paymasterPostOpGasLimit, paymasterVerificationGasLimit, ...rest } =\n    await client.request({\n      method: 'pm_getPaymasterStubData',\n      params: [\n        {\n          ...request,\n          callGasLimit: request.callGasLimit ?? '0x0',\n          verificationGasLimit: request.verificationGasLimit ?? '0x0',\n          preVerificationGas: request.preVerificationGas ?? '0x0',\n        },\n        entryPointAddress,\n        numberToHex(chainId),\n        context,\n      ],\n    })\n  return {\n    ...rest,\n    ...(paymasterPostOpGasLimit && {\n      paymasterPostOpGasLimit: hexToBigInt(paymasterPostOpGasLimit),\n    }),\n    ...(paymasterVerificationGasLimit && {\n      paymasterVerificationGasLimit: hexToBigInt(paymasterVerificationGasLimit),\n    }),\n  } as unknown as GetPaymasterStubDataReturnType\n}\n","import type { Address, Narrow } from 'abitype'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../../accounts/utils/parseAccount.js'\nimport { prepareAuthorization } from '../../../actions/index.js'\nimport {\n  type EstimateFeesPerGasErrorType,\n  estimateFeesPerGas,\n} from '../../../actions/public/estimateFeesPerGas.js'\nimport { getChainId as getChainId_ } from '../../../actions/public/getChainId.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../../errors/account.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { SignedAuthorization } from '../../../types/authorization.js'\nimport type { Call, Calls } from '../../../types/calls.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { StateOverride } from '../../../types/stateOverride.js'\nimport type {\n  Assign,\n  OneOf,\n  Prettify,\n  UnionOmit,\n} from '../../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../../utils/abi/encodeFunctionData.js'\nimport { type ConcatErrorType, concat } from '../../../utils/data/concat.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport type { BundlerClient } from '../../clients/createBundlerClient.js'\nimport type { PaymasterActions } from '../../clients/decorators/paymaster.js'\nimport type {\n  DeriveSmartAccount,\n  GetSmartAccountParameter,\n} from '../../types/account.js'\nimport type {\n  DeriveEntryPointVersion,\n  EntryPointVersion,\n} from '../../types/entryPointVersion.js'\nimport type {\n  UserOperation,\n  UserOperationRequest,\n} from '../../types/userOperation.js'\nimport {\n  type GetPaymasterDataErrorType,\n  getPaymasterData as getPaymasterData_,\n} from '../paymaster/getPaymasterData.js'\nimport {\n  type GetPaymasterStubDataErrorType,\n  getPaymasterStubData as getPaymasterStubData_,\n} from '../paymaster/getPaymasterStubData.js'\nimport {\n  type EstimateUserOperationGasParameters,\n  estimateUserOperationGas,\n} from './estimateUserOperationGas.js'\n\nconst defaultParameters = [\n  'factory',\n  'fees',\n  'gas',\n  'paymaster',\n  'nonce',\n  'signature',\n  'authorization',\n] as const\n\nexport type PrepareUserOperationParameterType =\n  | 'factory'\n  | 'fees'\n  | 'gas'\n  | 'paymaster'\n  | 'nonce'\n  | 'signature'\n  | 'authorization'\n\ntype FactoryProperties<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> =\n  | (entryPointVersion extends '0.8'\n      ? {\n          factory: UserOperation['factory']\n          factoryData: UserOperation['factoryData']\n        }\n      : never)\n  | (entryPointVersion extends '0.7'\n      ? {\n          factory: UserOperation['factory']\n          factoryData: UserOperation['factoryData']\n        }\n      : never)\n  | (entryPointVersion extends '0.6'\n      ? {\n          initCode: UserOperation['initCode']\n        }\n      : never)\n\ntype GasProperties<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> =\n  | (entryPointVersion extends '0.8'\n      ? {\n          callGasLimit: UserOperation['callGasLimit']\n          preVerificationGas: UserOperation['preVerificationGas']\n          verificationGasLimit: UserOperation['verificationGasLimit']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.7'\n      ? {\n          callGasLimit: UserOperation['callGasLimit']\n          preVerificationGas: UserOperation['preVerificationGas']\n          verificationGasLimit: UserOperation['verificationGasLimit']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.6'\n      ? {\n          callGasLimit: UserOperation['callGasLimit']\n          preVerificationGas: UserOperation['preVerificationGas']\n          verificationGasLimit: UserOperation['verificationGasLimit']\n        }\n      : never)\n\ntype FeeProperties = {\n  maxFeePerGas: UserOperation['maxFeePerGas']\n  maxPriorityFeePerGas: UserOperation['maxPriorityFeePerGas']\n}\n\ntype NonceProperties = {\n  nonce: UserOperation['nonce']\n}\n\ntype PaymasterProperties<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> =\n  | (entryPointVersion extends '0.8'\n      ? {\n          paymaster: UserOperation['paymaster']\n          paymasterData: UserOperation['paymasterData']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.7'\n      ? {\n          paymaster: UserOperation['paymaster']\n          paymasterData: UserOperation['paymasterData']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.6'\n      ? {\n          paymasterAndData: UserOperation['paymasterAndData']\n        }\n      : never)\n\ntype SignatureProperties = {\n  signature: UserOperation['signature']\n}\n\ntype AuthorizationProperties = {\n  authorization: UserOperation['authorization']\n}\n\nexport type PrepareUserOperationRequest<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = Assign<\n  UserOperationRequest<_derivedVersion>,\n  OneOf<{ calls: Calls<Narrow<calls>> } | { callData: Hex }> & {\n    parameters?: readonly PrepareUserOperationParameterType[] | undefined\n    paymaster?:\n      | Address\n      | true\n      | {\n          /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n          getPaymasterData?: PaymasterActions['getPaymasterData'] | undefined\n          /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n          getPaymasterStubData?:\n            | PaymasterActions['getPaymasterStubData']\n            | undefined\n        }\n      | undefined\n    /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n    paymasterContext?: unknown | undefined\n    /** State overrides for the User Operation call. */\n    stateOverride?: StateOverride | undefined\n  }\n>\n\nexport type PrepareUserOperationParameters<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  request extends PrepareUserOperationRequest<\n    account,\n    accountOverride,\n    calls\n  > = PrepareUserOperationRequest<account, accountOverride, calls>,\n> = request & GetSmartAccountParameter<account, accountOverride>\n\nexport type PrepareUserOperationReturnType<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  request extends PrepareUserOperationRequest<\n    account,\n    accountOverride,\n    calls\n  > = PrepareUserOperationRequest<account, accountOverride, calls>,\n  //\n  _parameters extends\n    PrepareUserOperationParameterType = request['parameters'] extends readonly PrepareUserOperationParameterType[]\n    ? request['parameters'][number]\n    : (typeof defaultParameters)[number],\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = Prettify<\n  UnionOmit<request, 'calls' | 'parameters'> & {\n    callData: Hex\n    paymasterAndData: _derivedVersion extends '0.6' ? Hex : undefined\n    sender: UserOperation['sender']\n  } & (Extract<_parameters, 'authorization'> extends never\n      ? {}\n      : AuthorizationProperties) &\n    (Extract<_parameters, 'factory'> extends never\n      ? {}\n      : FactoryProperties<_derivedVersion>) &\n    (Extract<_parameters, 'nonce'> extends never ? {} : NonceProperties) &\n    (Extract<_parameters, 'fees'> extends never ? {} : FeeProperties) &\n    (Extract<_parameters, 'gas'> extends never\n      ? {}\n      : GasProperties<_derivedVersion>) &\n    (Extract<_parameters, 'paymaster'> extends never\n      ? {}\n      : PaymasterProperties<_derivedVersion>) &\n    (Extract<_parameters, 'signature'> extends never ? {} : SignatureProperties)\n>\n\nexport type PrepareUserOperationErrorType =\n  | ParseAccountErrorType\n  | GetPaymasterStubDataErrorType\n  | GetPaymasterDataErrorType\n  | EncodeFunctionDataErrorType\n  | ConcatErrorType\n  | EstimateFeesPerGasErrorType\n  | ErrorType\n\n/**\n * Prepares a User Operation and fills in missing properties.\n *\n * - Docs: https://viem.sh/actions/bundler/prepareUserOperation\n *\n * @param args - {@link PrepareUserOperationParameters}\n * @returns The User Operation. {@link PrepareUserOperationReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { toSmartAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareUserOperation } from 'viem/actions'\n *\n * const account = await toSmartAccount({ ... })\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const request = await prepareUserOperation(client, {\n *   account,\n *   calls: [{ to: '0x...', value: parseEther('1') }],\n * })\n */\nexport async function prepareUserOperation<\n  account extends SmartAccount | undefined,\n  const calls extends readonly unknown[],\n  const request extends PrepareUserOperationRequest<\n    account,\n    accountOverride,\n    calls\n  >,\n  accountOverride extends SmartAccount | undefined = undefined,\n>(\n  client: Client<Transport, Chain | undefined, account>,\n  parameters_: PrepareUserOperationParameters<\n    account,\n    accountOverride,\n    calls,\n    request\n  >,\n): Promise<\n  PrepareUserOperationReturnType<account, accountOverride, calls, request>\n> {\n  const parameters = parameters_ as PrepareUserOperationParameters\n  const {\n    account: account_ = client.account,\n    parameters: properties = defaultParameters,\n    stateOverride,\n  } = parameters\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Assert that an Account is defined.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (!account_) throw new AccountNotFoundError()\n  const account = parseAccount(account_)\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Declare typed Bundler Client.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  const bundlerClient = client as unknown as BundlerClient\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Declare Paymaster properties.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  const paymaster = parameters.paymaster ?? bundlerClient?.paymaster\n  const paymasterAddress = typeof paymaster === 'string' ? paymaster : undefined\n  const { getPaymasterStubData, getPaymasterData } = (() => {\n    // If `paymaster: true`, we will assume the Bundler Client supports Paymaster Actions.\n    if (paymaster === true)\n      return {\n        getPaymasterStubData: (parameters: any) =>\n          getAction(\n            bundlerClient,\n            getPaymasterStubData_,\n            'getPaymasterStubData',\n          )(parameters),\n        getPaymasterData: (parameters: any) =>\n          getAction(\n            bundlerClient,\n            getPaymasterData_,\n            'getPaymasterData',\n          )(parameters),\n      }\n\n    // If Actions are passed to `paymaster` (via Paymaster Client or directly), we will use them.\n    if (typeof paymaster === 'object') {\n      const { getPaymasterStubData, getPaymasterData } = paymaster\n      return {\n        getPaymasterStubData: (getPaymasterData && getPaymasterStubData\n          ? getPaymasterStubData\n          : getPaymasterData) as typeof getPaymasterStubData,\n        getPaymasterData:\n          getPaymasterData && getPaymasterStubData\n            ? getPaymasterData\n            : undefined,\n      }\n    }\n\n    // No Paymaster functions.\n    return {\n      getPaymasterStubData: undefined,\n      getPaymasterData: undefined,\n    }\n  })()\n  const paymasterContext = parameters.paymasterContext\n    ? parameters.paymasterContext\n    : bundlerClient?.paymasterContext\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Set up the User Operation request.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  let request = {\n    ...parameters,\n    paymaster: paymasterAddress,\n    sender: account.address,\n  } as PrepareUserOperationRequest\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Concurrently prepare properties required to fill the User Operation.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  const [callData, factory, fees, nonce, authorization] = await Promise.all([\n    (async () => {\n      if (parameters.calls)\n        return account.encodeCalls(\n          parameters.calls.map((call_) => {\n            const call = call_ as Call\n            if (call.abi)\n              return {\n                data: encodeFunctionData(call),\n                to: call.to,\n                value: call.value,\n              } as Call\n            return call as Call\n          }),\n        )\n      return parameters.callData\n    })(),\n    (async () => {\n      if (!properties.includes('factory')) return undefined\n      if (parameters.initCode) return { initCode: parameters.initCode }\n      if (parameters.factory && parameters.factoryData) {\n        return {\n          factory: parameters.factory,\n          factoryData: parameters.factoryData,\n        }\n      }\n\n      const { factory, factoryData } = await account.getFactoryArgs()\n\n      if (account.entryPoint.version === '0.6')\n        return {\n          initCode:\n            factory && factoryData ? concat([factory, factoryData]) : undefined,\n        }\n      return {\n        factory,\n        factoryData,\n      }\n    })(),\n    (async () => {\n      if (!properties.includes('fees')) return undefined\n\n      // If we have sufficient properties for fees, return them.\n      if (\n        typeof parameters.maxFeePerGas === 'bigint' &&\n        typeof parameters.maxPriorityFeePerGas === 'bigint'\n      )\n        return request\n\n      // If the Bundler Client has a `estimateFeesPerGas` hook, run it.\n      if (bundlerClient?.userOperation?.estimateFeesPerGas) {\n        const fees = await bundlerClient.userOperation.estimateFeesPerGas({\n          account,\n          bundlerClient,\n          userOperation: request as UserOperation,\n        })\n        return {\n          ...request,\n          ...fees,\n        }\n      }\n\n      // Otherwise, we will need to estimate the fees to fill the fee properties.\n      try {\n        const client_ = bundlerClient.client ?? client\n        const fees = await getAction(\n          client_,\n          estimateFeesPerGas,\n          'estimateFeesPerGas',\n        )({\n          chain: client_.chain,\n          type: 'eip1559',\n        })\n        return {\n          maxFeePerGas:\n            typeof parameters.maxFeePerGas === 'bigint'\n              ? parameters.maxFeePerGas\n              : BigInt(\n                  // Bundlers unfortunately have strict rules on fee prechecks  we will need to set a generous buffer.\n                  2n * fees.maxFeePerGas,\n                ),\n          maxPriorityFeePerGas:\n            typeof parameters.maxPriorityFeePerGas === 'bigint'\n              ? parameters.maxPriorityFeePerGas\n              : BigInt(\n                  // Bundlers unfortunately have strict rules on fee prechecks  we will need to set a generous buffer.\n                  2n * fees.maxPriorityFeePerGas,\n                ),\n        }\n      } catch {\n        return undefined\n      }\n    })(),\n    (async () => {\n      if (!properties.includes('nonce')) return undefined\n      if (typeof parameters.nonce === 'bigint') return parameters.nonce\n      return account.getNonce()\n    })(),\n    (async () => {\n      if (!properties.includes('authorization')) return undefined\n      if (typeof parameters.authorization === 'object')\n        return parameters.authorization\n      if (account.authorization && !(await account.isDeployed())) {\n        const authorization = await prepareAuthorization(\n          account.client,\n          account.authorization,\n        )\n        return {\n          ...authorization,\n          r: '0xfffffffffffffffffffffffffffffff000000000000000000000000000000000',\n          s: '0x7aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n          yParity: 1,\n        } satisfies SignedAuthorization\n      }\n      return undefined\n    })(),\n  ])\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with the prepared properties from above.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (typeof callData !== 'undefined') request.callData = callData\n  if (typeof factory !== 'undefined')\n    request = { ...request, ...(factory as any) }\n  if (typeof fees !== 'undefined') request = { ...request, ...(fees as any) }\n  if (typeof nonce !== 'undefined') request.nonce = nonce\n  if (typeof authorization !== 'undefined')\n    request.authorization = authorization\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with the `signature` property.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (properties.includes('signature')) {\n    if (typeof parameters.signature !== 'undefined')\n      request.signature = parameters.signature\n    else\n      request.signature = await account.getStubSignature(\n        request as UserOperation,\n      )\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // `initCode` is required to be filled with EntryPoint 0.6.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  // If no `initCode` is provided, we use an empty bytes string.\n  if (account.entryPoint.version === '0.6' && !request.initCode)\n    request.initCode = '0x'\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with paymaster-related properties for **gas estimation**.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  let chainId: number | undefined\n  async function getChainId(): Promise<number> {\n    if (chainId) return chainId\n    if (client.chain) return client.chain.id\n    const chainId_ = await getAction(client, getChainId_, 'getChainId')({})\n    chainId = chainId_\n    return chainId\n  }\n\n  // If the User Operation is intended to be sponsored, we will need to fill the paymaster-related\n  // User Operation properties required to estimate the User Operation gas.\n  let isPaymasterPopulated = false\n  if (\n    properties.includes('paymaster') &&\n    getPaymasterStubData &&\n    !paymasterAddress &&\n    !parameters.paymasterAndData\n  ) {\n    const {\n      isFinal = false,\n      sponsor: _,\n      ...paymasterArgs\n    } = await getPaymasterStubData({\n      chainId: await getChainId(),\n      entryPointAddress: account.entryPoint.address,\n      context: paymasterContext,\n      ...(request as UserOperation),\n    })\n    isPaymasterPopulated = isFinal\n    request = {\n      ...request,\n      ...paymasterArgs,\n    } as PrepareUserOperationRequest\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // `paymasterAndData` is required to be filled with EntryPoint 0.6.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  // If no `paymasterAndData` is provided, we use an empty bytes string.\n  if (account.entryPoint.version === '0.6' && !request.paymasterAndData)\n    request.paymasterAndData = '0x'\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with gas-related properties.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (properties.includes('gas')) {\n    // If the Account has opinionated gas estimation logic, run the `estimateGas` hook and\n    // fill the request with the prepared gas properties.\n    if (account.userOperation?.estimateGas) {\n      const gas = await account.userOperation.estimateGas(\n        request as UserOperation,\n      )\n      request = {\n        ...request,\n        ...gas,\n      } as PrepareUserOperationRequest\n    }\n\n    // If not all the gas properties are already populated, we will need to estimate the gas\n    // to fill the gas properties.\n    if (\n      typeof request.callGasLimit === 'undefined' ||\n      typeof request.preVerificationGas === 'undefined' ||\n      typeof request.verificationGasLimit === 'undefined' ||\n      (request.paymaster &&\n        typeof request.paymasterPostOpGasLimit === 'undefined') ||\n      (request.paymaster &&\n        typeof request.paymasterVerificationGasLimit === 'undefined')\n    ) {\n      const gas = await getAction(\n        bundlerClient,\n        estimateUserOperationGas,\n        'estimateUserOperationGas',\n      )({\n        account,\n        // Some Bundlers fail if nullish gas values are provided for gas estimation :') \n        // so we will need to set a default zeroish value.\n        callGasLimit: 0n,\n        preVerificationGas: 0n,\n        verificationGasLimit: 0n,\n        stateOverride,\n        ...(request.paymaster\n          ? {\n              paymasterPostOpGasLimit: 0n,\n              paymasterVerificationGasLimit: 0n,\n            }\n          : {}),\n        ...request,\n      } as EstimateUserOperationGasParameters)\n      request = {\n        ...request,\n        callGasLimit: request.callGasLimit ?? gas.callGasLimit,\n        preVerificationGas:\n          request.preVerificationGas ?? gas.preVerificationGas,\n        verificationGasLimit:\n          request.verificationGasLimit ?? gas.verificationGasLimit,\n        paymasterPostOpGasLimit:\n          request.paymasterPostOpGasLimit ?? gas.paymasterPostOpGasLimit,\n        paymasterVerificationGasLimit:\n          request.paymasterVerificationGasLimit ??\n          gas.paymasterVerificationGasLimit,\n      } as PrepareUserOperationRequest\n    }\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with paymaster-related properties for **sending** the User Operation.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  // If the User Operation is intended to be sponsored, we will need to fill the paymaster-related\n  // User Operation properties required to send the User Operation.\n  if (\n    properties.includes('paymaster') &&\n    getPaymasterData &&\n    !paymasterAddress &&\n    !parameters.paymasterAndData &&\n    !isPaymasterPopulated\n  ) {\n    // Retrieve paymaster-related User Operation properties to be used for **sending** the User Operation.\n    const paymaster = await getPaymasterData({\n      chainId: await getChainId(),\n      entryPointAddress: account.entryPoint.address,\n      context: paymasterContext,\n      ...(request as UserOperation),\n    })\n    request = {\n      ...request,\n      ...paymaster,\n    } as PrepareUserOperationRequest\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Remove redundant properties that do not conform to the User Operation schema.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  delete request.calls\n  delete request.parameters\n  delete request.paymasterContext\n  if (typeof request.paymaster !== 'string') delete request.paymaster\n\n  ////////////////////////////////////////////////////////////////////////////////\n\n  return request as unknown as PrepareUserOperationReturnType<\n    account,\n    accountOverride,\n    calls,\n    request\n  >\n}\n","import type { Address } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n} from '../../errors/account.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Authorization,\n  AuthorizationRequest,\n} from '../../types/authorization.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { PartialBy } from '../../types/utils.js'\nimport { isAddressEqual } from '../../utils/address/isAddressEqual.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { getChainId } from '../public/getChainId.js'\nimport { getTransactionCount } from '../public/getTransactionCount.js'\n\nexport type PrepareAuthorizationParameters<\n  account extends Account | undefined = Account | undefined,\n> = GetAccountParameter<account> &\n  PartialBy<AuthorizationRequest, 'chainId' | 'nonce'> & {\n    /**\n     * Whether the EIP-7702 Transaction will be executed by the EOA (signing this Authorization) or another Account.\n     *\n     * By default, it will be assumed that the EIP-7702 Transaction will\n     * be executed by another Account.\n     */\n    executor?: 'self' | Account | Address | undefined\n  }\n\nexport type PrepareAuthorizationReturnType = Authorization\n\nexport type PrepareAuthorizationErrorType =\n  | ParseAccountErrorType\n  | RequestErrorType\n  | AccountNotFoundErrorType\n  | ErrorType\n\n/**\n * Prepares an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) object for signing.\n * This Action will fill the required fields of the Authorization object if they are not provided (e.g. `nonce` and `chainId`).\n *\n * With the prepared Authorization object, you can use [`signAuthorization`](https://viem.sh/docs/eip7702/signAuthorization) to sign over the Authorization object.\n *\n * @param client - Client to use\n * @param parameters - {@link PrepareAuthorizationParameters}\n * @returns The prepared Authorization object. {@link PrepareAuthorizationReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareAuthorization } from 'viem/experimental'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const authorization = await prepareAuthorization(client, {\n *   account: privateKeyToAccount('0x..'),\n *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n *\n * @example\n * // Account Hoisting\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareAuthorization } from 'viem/experimental'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const authorization = await prepareAuthorization(client, {\n *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function prepareAuthorization<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: PrepareAuthorizationParameters<account>,\n): Promise<PrepareAuthorizationReturnType> {\n  const { account: account_ = client.account, chainId, nonce } = parameters\n\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/eip7702/prepareAuthorization',\n    })\n  const account = parseAccount(account_)\n\n  const executor = (() => {\n    if (!parameters.executor) return undefined\n    if (parameters.executor === 'self') return parameters.executor\n    return parseAccount(parameters.executor)\n  })()\n\n  const authorization = {\n    address: parameters.contractAddress ?? parameters.address,\n    chainId,\n    nonce,\n  } as Authorization\n\n  if (typeof authorization.chainId === 'undefined')\n    authorization.chainId =\n      client.chain?.id ??\n      (await getAction(client, getChainId, 'getChainId')({}))\n\n  if (typeof authorization.nonce === 'undefined') {\n    authorization.nonce = await getAction(\n      client,\n      getTransactionCount,\n      'getTransactionCount',\n    )({\n      address: account.address,\n      blockTag: 'pending',\n    })\n    if (\n      executor === 'self' ||\n      (executor?.address && isAddressEqual(executor.address, account.address))\n    )\n      authorization.nonce += 1\n  }\n\n  return authorization\n}\n","import type { Address, Narrow } from 'abitype'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../../errors/account.js'\nimport type { BaseError } from '../../../errors/base.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Calls } from '../../../types/calls.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { StateOverride } from '../../../types/stateOverride.js'\nimport type {\n  Assign,\n  MaybeRequired,\n  OneOf,\n  Prettify,\n} from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport { serializeStateOverride } from '../../../utils/stateOverride.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport type { PaymasterActions } from '../../clients/decorators/paymaster.js'\nimport type {\n  DeriveSmartAccount,\n  GetSmartAccountParameter,\n} from '../../types/account.js'\nimport type {\n  DeriveEntryPointVersion,\n  EntryPointVersion,\n} from '../../types/entryPointVersion.js'\nimport type {\n  EstimateUserOperationGasReturnType as EstimateUserOperationGasReturnType_,\n  UserOperation,\n  UserOperationRequest,\n} from '../../types/userOperation.js'\nimport { getUserOperationError } from '../../utils/errors/getUserOperationError.js'\nimport {\n  type FormatUserOperationGasErrorType,\n  formatUserOperationGas,\n} from '../../utils/formatters/userOperationGas.js'\nimport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from '../../utils/formatters/userOperationRequest.js'\nimport {\n  type PrepareUserOperationErrorType,\n  type PrepareUserOperationParameters,\n  prepareUserOperation,\n} from './prepareUserOperation.js'\n\nexport type EstimateUserOperationGasParameters<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = GetSmartAccountParameter<account, accountOverride, false> &\n  (\n    | UserOperation // Accept a full-formed User Operation.\n    | Assign<\n        // Accept a partially-formed User Operation (UserOperationRequest) to be filled.\n        UserOperationRequest<_derivedVersion>,\n        OneOf<{ calls: Calls<Narrow<calls>> } | { callData: Hex }> & {\n          paymaster?:\n            | Address\n            | true\n            | {\n                /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n                getPaymasterData?:\n                  | PaymasterActions['getPaymasterData']\n                  | undefined\n                /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n                getPaymasterStubData?:\n                  | PaymasterActions['getPaymasterStubData']\n                  | undefined\n              }\n            | undefined\n          /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n          paymasterContext?: unknown | undefined\n        }\n      >\n  ) &\n  // Allow the EntryPoint address to be overridden, if no Account is provided, it will need to be required.\n  MaybeRequired<\n    { entryPointAddress?: Address },\n    _derivedAccount extends undefined ? true : false\n  > & {\n    /** State overrides for the User Operation call. */\n    stateOverride?: StateOverride | undefined\n  }\n\nexport type EstimateUserOperationGasReturnType<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = Prettify<EstimateUserOperationGasReturnType_<_derivedVersion>>\n\nexport type EstimateUserOperationGasErrorType =\n  | ParseAccountErrorType\n  | PrepareUserOperationErrorType\n  | FormatUserOperationRequestErrorType\n  | FormatUserOperationGasErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns an estimate of gas values necessary to execute the User Operation.\n *\n * - Docs: https://viem.sh/actions/bundler/estimateUserOperationGas\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateUserOperationGasParameters}\n * @returns The gas estimate (in wei). {@link EstimateUserOperationGasReturnType}\n *\n * @example\n * import { createBundlerClient, http, parseEther } from 'viem'\n * import { toSmartAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { estimateUserOperationGas } from 'viem/actions'\n *\n * const account = await toSmartAccount({ ... })\n *\n * const bundlerClient = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const values = await estimateUserOperationGas(bundlerClient, {\n *   account,\n *   calls: [{ to: '0x...', value: parseEther('1') }],\n * })\n */\nexport async function estimateUserOperationGas<\n  const calls extends readonly unknown[],\n  account extends SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = undefined,\n>(\n  client: Client<Transport, Chain | undefined, account>,\n  parameters: EstimateUserOperationGasParameters<\n    account,\n    accountOverride,\n    calls\n  >,\n): Promise<EstimateUserOperationGasReturnType<account, accountOverride>> {\n  const {\n    account: account_ = client.account,\n    entryPointAddress,\n    stateOverride,\n  } = parameters\n\n  if (!account_ && !parameters.sender) throw new AccountNotFoundError()\n  const account = account_ ? parseAccount(account_) : undefined\n\n  const rpcStateOverride = serializeStateOverride(stateOverride)\n\n  const request = account\n    ? await getAction(\n        client,\n        prepareUserOperation,\n        'prepareUserOperation',\n      )({\n        ...parameters,\n        parameters: [\n          'authorization',\n          'factory',\n          'nonce',\n          'paymaster',\n          'signature',\n        ],\n      } as unknown as PrepareUserOperationParameters)\n    : parameters\n\n  try {\n    const params = [\n      formatUserOperationRequest(request as UserOperation),\n      (entryPointAddress ?? account?.entryPoint?.address)!,\n    ] as const\n\n    const result = await client.request({\n      method: 'eth_estimateUserOperationGas',\n      params: rpcStateOverride ? [...params, rpcStateOverride] : [...params],\n    })\n    return formatUserOperationGas(result) as EstimateUserOperationGasReturnType<\n      account,\n      accountOverride\n    >\n  } catch (error) {\n    const calls = (parameters as any).calls\n    throw getUserOperationError(error as BaseError, {\n      ...(request as UserOperation),\n      ...(calls ? { calls } : {}),\n    })\n  }\n}\n","import type { ErrorType } from '../../../errors/utils.js'\nimport type { RpcEstimateUserOperationGasReturnType } from '../../types/rpc.js'\nimport type { EstimateUserOperationGasReturnType } from '../../types/userOperation.js'\n\nexport type FormatUserOperationGasErrorType = ErrorType\n\nexport function formatUserOperationGas(\n  parameters: RpcEstimateUserOperationGasReturnType,\n): EstimateUserOperationGasReturnType {\n  const gas = {} as EstimateUserOperationGasReturnType\n\n  if (parameters.callGasLimit)\n    gas.callGasLimit = BigInt(parameters.callGasLimit)\n  if (parameters.preVerificationGas)\n    gas.preVerificationGas = BigInt(parameters.preVerificationGas)\n  if (parameters.verificationGasLimit)\n    gas.verificationGasLimit = BigInt(parameters.verificationGasLimit)\n  if (parameters.paymasterPostOpGasLimit)\n    gas.paymasterPostOpGasLimit = BigInt(parameters.paymasterPostOpGasLimit)\n  if (parameters.paymasterVerificationGasLimit)\n    gas.paymasterVerificationGasLimit = BigInt(\n      parameters.paymasterVerificationGasLimit,\n    )\n\n  return gas\n}\n","import type { ErrorType } from '../../../errors/utils.js'\nimport type { RpcUserOperation } from '../../types/rpc.js'\nimport type { UserOperation } from '../../types/userOperation.js'\n\nexport type FormatUserOperationErrorType = ErrorType\n\nexport function formatUserOperation(parameters: RpcUserOperation) {\n  const userOperation = { ...parameters } as unknown as UserOperation\n\n  if (parameters.callGasLimit)\n    userOperation.callGasLimit = BigInt(parameters.callGasLimit)\n  if (parameters.maxFeePerGas)\n    userOperation.maxFeePerGas = BigInt(parameters.maxFeePerGas)\n  if (parameters.maxPriorityFeePerGas)\n    userOperation.maxPriorityFeePerGas = BigInt(parameters.maxPriorityFeePerGas)\n  if (parameters.nonce) userOperation.nonce = BigInt(parameters.nonce)\n  if (parameters.paymasterPostOpGasLimit)\n    userOperation.paymasterPostOpGasLimit = BigInt(\n      parameters.paymasterPostOpGasLimit,\n    )\n  if (parameters.paymasterVerificationGasLimit)\n    userOperation.paymasterVerificationGasLimit = BigInt(\n      parameters.paymasterVerificationGasLimit,\n    )\n  if (parameters.preVerificationGas)\n    userOperation.preVerificationGas = BigInt(parameters.preVerificationGas)\n  if (parameters.verificationGasLimit)\n    userOperation.verificationGasLimit = BigInt(parameters.verificationGasLimit)\n\n  return userOperation\n}\n","import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hash } from '../../../types/misc.js'\nimport type { Prettify } from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport {\n  UserOperationReceiptNotFoundError,\n  type UserOperationReceiptNotFoundErrorType,\n} from '../../errors/userOperation.js'\nimport type { UserOperationReceipt } from '../../types/userOperation.js'\nimport { formatUserOperationReceipt } from '../../utils/formatters/userOperationReceipt.js'\n\nexport type GetUserOperationReceiptParameters = {\n  /** The hash of the User Operation. */\n  hash: Hash\n}\n\nexport type GetUserOperationReceiptReturnType = Prettify<UserOperationReceipt>\n\nexport type GetUserOperationReceiptErrorType =\n  | RequestErrorType\n  | UserOperationReceiptNotFoundErrorType\n  | ErrorType\n\n/**\n * Returns the User Operation Receipt given a User Operation hash.\n *\n * - Docs: https://viem.sh/docs/actions/bundler/getUserOperationReceipt\n *\n * @param client - Client to use\n * @param parameters - {@link GetUserOperationReceiptParameters}\n * @returns The receipt. {@link GetUserOperationReceiptReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getUserOperationReceipt } from 'viem/actions\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getUserOperationReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function getUserOperationReceipt(\n  client: Client<Transport>,\n  { hash }: GetUserOperationReceiptParameters,\n) {\n  const receipt = await client.request(\n    {\n      method: 'eth_getUserOperationReceipt',\n      params: [hash],\n    },\n    { dedupe: true },\n  )\n\n  if (!receipt) throw new UserOperationReceiptNotFoundError({ hash })\n\n  return formatUserOperationReceipt(receipt)\n}\n","import type { ErrorType } from '../../../errors/utils.js'\nimport { formatLog } from '../../../utils/formatters/log.js'\nimport { formatTransactionReceipt } from '../../../utils/formatters/transactionReceipt.js'\nimport type { RpcUserOperationReceipt } from '../../types/rpc.js'\nimport type { UserOperationReceipt } from '../../types/userOperation.js'\n\nexport type FormatUserOperationReceiptErrorType = ErrorType\n\nexport function formatUserOperationReceipt(\n  parameters: RpcUserOperationReceipt,\n) {\n  const receipt = { ...parameters } as unknown as UserOperationReceipt\n\n  if (parameters.actualGasCost)\n    receipt.actualGasCost = BigInt(parameters.actualGasCost)\n  if (parameters.actualGasUsed)\n    receipt.actualGasUsed = BigInt(parameters.actualGasUsed)\n  if (parameters.logs)\n    receipt.logs = parameters.logs.map((log) => formatLog(log)) as any\n  if (parameters.receipt)\n    receipt.receipt = formatTransactionReceipt(receipt.receipt as any)\n\n  return receipt\n}\n","import {\n  type GetChainIdReturnType,\n  getChainId,\n} from '../../../actions/public/getChainId.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport {\n  type EstimateUserOperationGasParameters,\n  type EstimateUserOperationGasReturnType,\n  estimateUserOperationGas,\n} from '../../actions/bundler/estimateUserOperationGas.js'\nimport {\n  type GetSupportedEntryPointsReturnType,\n  getSupportedEntryPoints,\n} from '../../actions/bundler/getSupportedEntryPoints.js'\nimport {\n  type GetUserOperationParameters,\n  type GetUserOperationReturnType,\n  getUserOperation,\n} from '../../actions/bundler/getUserOperation.js'\nimport {\n  type GetUserOperationReceiptParameters,\n  type GetUserOperationReceiptReturnType,\n  getUserOperationReceipt,\n} from '../../actions/bundler/getUserOperationReceipt.js'\nimport {\n  type PrepareUserOperationParameters,\n  type PrepareUserOperationRequest,\n  type PrepareUserOperationReturnType,\n  prepareUserOperation,\n} from '../../actions/bundler/prepareUserOperation.js'\nimport {\n  type SendUserOperationParameters,\n  type SendUserOperationReturnType,\n  sendUserOperation,\n} from '../../actions/bundler/sendUserOperation.js'\nimport {\n  type WaitForUserOperationReceiptParameters,\n  type WaitForUserOperationReceiptReturnType,\n  waitForUserOperationReceipt,\n} from '../../actions/bundler/waitForUserOperationReceipt.js'\n\nexport type BundlerActions<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n> = {\n  /**\n   * Returns an estimate of gas values necessary to execute the User Operation.\n   *\n   * - Docs: https://viem.sh/actions/bundler/estimateUserOperationGas\n   *\n   * @param client - Client to use\n   * @param parameters - {@link EstimateUserOperationGasParameters}\n   * @returns The gas estimate (in wei). {@link EstimateUserOperationGasReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http, parseEther } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { toSmartAccount } from 'viem/accounts'\n   *\n   * const account = await toSmartAccount({ ... })\n   *\n   * const bundlerClient = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const values = await bundlerClient.estimateUserOperationGas({\n   *   account,\n   *   calls: [{ to: '0x...', value: parseEther('1') }],\n   * })\n   */\n  estimateUserOperationGas: <\n    const calls extends readonly unknown[],\n    accountOverride extends SmartAccount | undefined = undefined,\n  >(\n    parameters: EstimateUserOperationGasParameters<\n      account,\n      accountOverride,\n      calls\n    >,\n  ) => Promise<EstimateUserOperationGasReturnType<account, accountOverride>>\n  /**\n   * Returns the chain ID associated with the bundler.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getChainId\n   * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)\n   *\n   * @returns The current chain ID. {@link GetChainIdReturnType}\n   *\n   * @example\n   * import { http } from 'viem'\n   * import { createBundlerClient, mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const chainId = await client.getChainId()\n   * // 1\n   */\n  getChainId: () => Promise<GetChainIdReturnType>\n  /**\n   * Returns the EntryPoints that the bundler supports.\n   *\n   * - Docs: https://viem.sh/actions/bundler/getSupportedEntryPoints\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetSupportedEntryPointsParameters}\n   * @returns Supported Entry Points. {@link GetSupportedEntryPointsReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http, parseEther } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const bundlerClient = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const addresses = await bundlerClient.getSupportedEntryPoints()\n   */\n  getSupportedEntryPoints: () => Promise<GetSupportedEntryPointsReturnType>\n  /**\n   * Returns the information about a User Operation given a hash.\n   *\n   * - Docs: https://viem.sh/docs/actions/bundler/getUserOperation\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetUserOperationParameters}\n   * @returns The receipt. {@link GetUserOperationReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const receipt = await client.getUserOperation({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  getUserOperation: (\n    parameters: GetUserOperationParameters,\n  ) => Promise<GetUserOperationReturnType>\n  /**\n   * Returns the User Operation Receipt given a User Operation hash.\n   *\n   * - Docs: https://viem.sh/docs/actions/bundler/getUserOperationReceipt\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetUserOperationReceiptParameters}\n   * @returns The receipt. {@link GetUserOperationReceiptReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const receipt = await client.getUserOperationReceipt({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  getUserOperationReceipt: (\n    parameters: GetUserOperationReceiptParameters,\n  ) => Promise<GetUserOperationReceiptReturnType>\n  /**\n   * Prepares a User Operation and fills in missing properties.\n   *\n   * - Docs: https://viem.sh/actions/bundler/prepareUserOperation\n   *\n   * @param args - {@link PrepareUserOperationParameters}\n   * @returns The User Operation. {@link PrepareUserOperationReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { toSmartAccount } from 'viem/accounts'\n   *\n   * const account = await toSmartAccount({ ... })\n   *\n   * const client = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const request = await client.prepareUserOperation({\n   *   account,\n   *   calls: [{ to: '0x...', value: parseEther('1') }],\n   * })\n   */\n  prepareUserOperation: <\n    const calls extends readonly unknown[],\n    const request extends PrepareUserOperationRequest<\n      account,\n      accountOverride,\n      calls\n    >,\n    accountOverride extends SmartAccount | undefined = undefined,\n  >(\n    parameters: PrepareUserOperationParameters<\n      account,\n      accountOverride,\n      calls,\n      request\n    >,\n  ) => Promise<\n    PrepareUserOperationReturnType<account, accountOverride, calls, request>\n  >\n  /**\n   * Broadcasts a User Operation to the Bundler.\n   *\n   * - Docs: https://viem.sh/actions/bundler/sendUserOperation\n   *\n   * @param client - Client to use\n   * @param parameters - {@link SendUserOperationParameters}\n   * @returns The User Operation hash. {@link SendUserOperationReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http, parseEther } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { toSmartAccount } from 'viem/accounts'\n   *\n   * const account = toSmartAccount({ ... })\n   *\n   * const bundlerClient = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const values = await bundlerClient.sendUserOperation({\n   *   account,\n   *   calls: [{ to: '0x...', value: parseEther('1') }],\n   * })\n   */\n  sendUserOperation: <\n    const calls extends readonly unknown[],\n    accountOverride extends SmartAccount | undefined = undefined,\n  >(\n    parameters: SendUserOperationParameters<account, accountOverride, calls>,\n  ) => Promise<SendUserOperationReturnType>\n  /**\n   * Waits for the User Operation to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the User Operation receipt.\n   *\n   * - Docs: https://viem.sh/docs/actions/bundler/waitForUserOperationReceipt\n   *\n   * @param client - Client to use\n   * @param parameters - {@link WaitForUserOperationReceiptParameters}\n   * @returns The receipt. {@link WaitForUserOperationReceiptReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const receipt = await client.waitForUserOperationReceipt({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  waitForUserOperationReceipt: (\n    parameters: WaitForUserOperationReceiptParameters,\n  ) => Promise<WaitForUserOperationReceiptReturnType>\n}\n\nexport function bundlerActions<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n>(client: Client<transport, chain, account>): BundlerActions<account> {\n  return {\n    estimateUserOperationGas: (parameters) =>\n      estimateUserOperationGas(client, parameters),\n    getChainId: () => getChainId(client),\n    getSupportedEntryPoints: () => getSupportedEntryPoints(client),\n    getUserOperation: (parameters) => getUserOperation(client, parameters),\n    getUserOperationReceipt: (parameters) =>\n      getUserOperationReceipt(client, parameters),\n    prepareUserOperation: (parameters) =>\n      prepareUserOperation(client, parameters),\n    sendUserOperation: (parameters) => sendUserOperation(client, parameters),\n    waitForUserOperationReceipt: (parameters) =>\n      waitForUserOperationReceipt(client, parameters),\n  }\n}\n","import type { Address } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\n\nexport type GetSupportedEntryPointsReturnType = readonly Address[]\nexport type GetSupportedEntryPointsErrorType = RequestErrorType | ErrorType\n\n/**\n * Returns the EntryPoints that the bundler supports.\n *\n * - Docs: https://viem.sh/actions/bundler/getSupportedEntryPoints\n *\n * @param client - Client to use\n * @param parameters - {@link GetSupportedEntryPointsParameters}\n * @returns Supported Entry Points. {@link GetSupportedEntryPointsReturnType}\n *\n * @example\n * import { createBundlerClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getSupportedEntryPoints } from 'viem/actions'\n *\n * const bundlerClient = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const addresses = await getSupportedEntryPoints(bundlerClient)\n */\nexport function getSupportedEntryPoints(client: Client<Transport>) {\n  return client.request({ method: 'eth_supportedEntryPoints' })\n}\n","import type { Address } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hash } from '../../../types/misc.js'\nimport type { Prettify } from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport {\n  UserOperationNotFoundError,\n  type UserOperationNotFoundErrorType,\n} from '../../errors/userOperation.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport { formatUserOperation } from '../../utils/formatters/userOperation.js'\n\nexport type GetUserOperationParameters = {\n  /** The hash of the User Operation. */\n  hash: Hash\n}\n\nexport type GetUserOperationReturnType = Prettify<{\n  /** The block hash the User Operation was included on. */\n  blockHash: Hash\n  /** The block number the User Operation was included on. */\n  blockNumber: bigint\n  /** The EntryPoint which handled the User Operation. */\n  entryPoint: Address\n  /** The hash of the transaction which included the User Operation. */\n  transactionHash: Hash\n  /** The User Operation. */\n  userOperation: UserOperation\n}>\n\nexport type GetUserOperationErrorType =\n  | RequestErrorType\n  | UserOperationNotFoundErrorType\n  | ErrorType\n\n/**\n * Retrieves information about a User Operation given a hash.\n *\n * - Docs: https://viem.sh/account-abstraction/actions/bundler/getUserOperation\n *\n * @param client - Client to use\n * @param parameters - {@link GetUserOperationParameters}\n * @returns The receipt. {@link GetUserOperationReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getUserOperation } from 'viem/actions\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getUserOperation(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function getUserOperation(\n  client: Client<Transport>,\n  { hash }: GetUserOperationParameters,\n) {\n  const result = await client.request(\n    {\n      method: 'eth_getUserOperationByHash',\n      params: [hash],\n    },\n    { dedupe: true },\n  )\n\n  if (!result) throw new UserOperationNotFoundError({ hash })\n\n  const { blockHash, blockNumber, entryPoint, transactionHash, userOperation } =\n    result\n\n  return {\n    blockHash,\n    blockNumber: BigInt(blockNumber),\n    entryPoint,\n    transactionHash,\n    userOperation: formatUserOperation(userOperation),\n  }\n}\n","import type { Address, Narrow } from 'abitype'\nimport { parseAccount } from '../../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../../errors/account.js'\nimport type { BaseError } from '../../../errors/base.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Calls } from '../../../types/calls.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { Assign, MaybeRequired, OneOf } from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport type { PaymasterActions } from '../../clients/decorators/paymaster.js'\nimport type {\n  DeriveSmartAccount,\n  GetSmartAccountParameter,\n} from '../../types/account.js'\nimport type {\n  DeriveEntryPointVersion,\n  EntryPointVersion,\n} from '../../types/entryPointVersion.js'\nimport type {\n  UserOperation,\n  UserOperationRequest,\n} from '../../types/userOperation.js'\nimport { getUserOperationError } from '../../utils/errors/getUserOperationError.js'\nimport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from '../../utils/formatters/userOperationRequest.js'\nimport {\n  type PrepareUserOperationErrorType,\n  type PrepareUserOperationParameters,\n  prepareUserOperation,\n} from './prepareUserOperation.js'\n\nexport type SendUserOperationParameters<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = GetSmartAccountParameter<account, accountOverride, false> &\n  (\n    | UserOperation // Accept a full-formed User Operation.\n    | Assign<\n        // Accept a partially-formed User Operation (UserOperationRequest) to be filled.\n        UserOperationRequest<_derivedVersion>,\n        OneOf<{ calls: Calls<Narrow<calls>> } | { callData: Hex }> & {\n          paymaster?:\n            | Address\n            | true\n            | {\n                /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n                getPaymasterData?:\n                  | PaymasterActions['getPaymasterData']\n                  | undefined\n                /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n                getPaymasterStubData?:\n                  | PaymasterActions['getPaymasterStubData']\n                  | undefined\n              }\n            | undefined\n          /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n          paymasterContext?: unknown | undefined\n        }\n      >\n  ) &\n  // Allow the EntryPoint address to be overridden, if no Account is provided, it will need to be required.\n  MaybeRequired<\n    { entryPointAddress?: Address },\n    _derivedAccount extends undefined ? true : false\n  >\nexport type SendUserOperationReturnType = Hex\n\nexport type SendUserOperationErrorType =\n  | FormatUserOperationRequestErrorType\n  | PrepareUserOperationErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Broadcasts a User Operation to the Bundler.\n *\n * - Docs: https://viem.sh/actions/bundler/sendUserOperation\n *\n * @param client - Client to use\n * @param parameters - {@link SendUserOperationParameters}\n * @returns The User Operation hash. {@link SendUserOperationReturnType}\n *\n * @example\n * import { createBundlerClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { toSmartAccount } from 'viem/accounts'\n * import { sendUserOperation } from 'viem/actions'\n *\n * const account = await toSmartAccount({ ... })\n *\n * const bundlerClient = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const values = await sendUserOperation(bundlerClient, {\n *   account,\n *   calls: [{ to: '0x...', value: parseEther('1') }],\n * })\n */\nexport async function sendUserOperation<\n  const calls extends readonly unknown[],\n  account extends SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = undefined,\n>(\n  client: Client<Transport, Chain | undefined, account>,\n  parameters: SendUserOperationParameters<account, accountOverride, calls>,\n) {\n  const { account: account_ = client.account, entryPointAddress } = parameters\n\n  if (!account_ && !parameters.sender) throw new AccountNotFoundError()\n  const account = account_ ? parseAccount(account_) : undefined\n\n  const request = account\n    ? await getAction(\n        client,\n        prepareUserOperation,\n        'prepareUserOperation',\n      )(parameters as unknown as PrepareUserOperationParameters)\n    : parameters\n\n  const signature = (parameters.signature ||\n    (await account?.signUserOperation?.(request as UserOperation)))!\n\n  const rpcParameters = formatUserOperationRequest({\n    ...request,\n    signature,\n  } as UserOperation)\n\n  try {\n    return await client.request(\n      {\n        method: 'eth_sendUserOperation',\n        params: [\n          rpcParameters,\n          (entryPointAddress ?? account?.entryPoint?.address)!,\n        ],\n      },\n      { retryCount: 0 },\n    )\n  } catch (error) {\n    const calls = (parameters as any).calls\n    throw getUserOperationError(error as BaseError, {\n      ...(request as UserOperation),\n      ...(calls ? { calls } : {}),\n      signature,\n    })\n  }\n}\n","import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hash } from '../../../types/misc.js'\nimport type { Prettify } from '../../../types/utils.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../../utils/observe.js'\nimport { type PollErrorType, poll } from '../../../utils/poll.js'\nimport { stringify } from '../../../utils/stringify.js'\nimport {\n  WaitForUserOperationReceiptTimeoutError,\n  type WaitForUserOperationReceiptTimeoutErrorType,\n} from '../../errors/userOperation.js'\nimport type { UserOperationReceipt } from '../../types/userOperation.js'\nimport {\n  type GetUserOperationReceiptErrorType,\n  getUserOperationReceipt,\n} from './getUserOperationReceipt.js'\n\nexport type WaitForUserOperationReceiptParameters = {\n  /** The hash of the User Operation. */\n  hash: Hash\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * The number of times to retry.\n   * @default 6\n   */\n  retryCount?: number | undefined\n  /** Optional timeout (in ms) to wait before stopping polling. */\n  timeout?: number | undefined\n}\n\nexport type WaitForUserOperationReceiptReturnType =\n  Prettify<UserOperationReceipt>\n\nexport type WaitForUserOperationReceiptErrorType =\n  | WaitForUserOperationReceiptTimeoutErrorType\n  | PollErrorType\n  | ObserveErrorType\n  | ErrorType\n\n/**\n * Waits for the User Operation to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the User Operation receipt.\n *\n * - Docs: https://viem.sh/docs/actions/bundler/waitForUserOperationReceipt\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForUserOperationReceiptParameters}\n * @returns The receipt. {@link WaitForUserOperationReceiptReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForUserOperationReceipt } from 'viem/actions'\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await waitForUserOperationReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport function waitForUserOperationReceipt(\n  client: Client<Transport>,\n  parameters: WaitForUserOperationReceiptParameters,\n): Promise<WaitForUserOperationReceiptReturnType> {\n  const {\n    hash,\n    pollingInterval = client.pollingInterval,\n    retryCount,\n    timeout = 120_000,\n  } = parameters\n\n  let count = 0\n  const observerId = stringify([\n    'waitForUserOperationReceipt',\n    client.uid,\n    hash,\n  ])\n\n  return new Promise((resolve, reject) => {\n    const unobserve = observe(observerId, { resolve, reject }, (emit) => {\n      const done = (fn: () => void) => {\n        unpoll()\n        fn()\n        unobserve()\n      }\n\n      const unpoll = poll(\n        async () => {\n          if (retryCount && count >= retryCount)\n            done(() =>\n              emit.reject(\n                new WaitForUserOperationReceiptTimeoutError({ hash }),\n              ),\n            )\n\n          try {\n            const receipt = await getAction(\n              client,\n              getUserOperationReceipt,\n              'getUserOperationReceipt',\n            )({ hash })\n            done(() => emit.resolve(receipt))\n          } catch (err) {\n            const error = err as GetUserOperationReceiptErrorType\n            if (error.name !== 'UserOperationReceiptNotFoundError')\n              done(() => emit.reject(error))\n          }\n\n          count++\n        },\n        {\n          emitOnBegin: true,\n          interval: pollingInterval,\n        },\n      )\n\n      if (timeout)\n        setTimeout(\n          () =>\n            done(() =>\n              emit.reject(\n                new WaitForUserOperationReceiptTimeoutError({ hash }),\n              ),\n            ),\n          timeout,\n        )\n\n      return unpoll\n    })\n  })\n}\n","import type { EstimateFeesPerGasReturnType } from '../../actions/public/estimateFeesPerGas.js'\nimport {\n  type Client,\n  type ClientConfig,\n  type CreateClientErrorType,\n  createClient,\n} from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { BundlerRpcSchema, RpcSchema } from '../../types/eip1193.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { SmartAccount } from '../accounts/types.js'\nimport type { UserOperationRequest } from '../types/userOperation.js'\nimport { type BundlerActions, bundlerActions } from './decorators/bundler.js'\nimport type { PaymasterActions } from './decorators/paymaster.js'\n\nexport type BundlerClientConfig<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  client extends Client | undefined = Client | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = Prettify<\n  Pick<\n    ClientConfig<transport, chain, account, rpcSchema>,\n    | 'account'\n    | 'cacheTime'\n    | 'chain'\n    | 'key'\n    | 'name'\n    | 'pollingInterval'\n    | 'rpcSchema'\n    | 'transport'\n  >\n> & {\n  /** Client that points to an Execution RPC URL. */\n  client?: client | Client | undefined\n  /** Paymaster configuration. */\n  paymaster?:\n    | true\n    | {\n        /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n        getPaymasterData?: PaymasterActions['getPaymasterData'] | undefined\n        /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n        getPaymasterStubData?:\n          | PaymasterActions['getPaymasterStubData']\n          | undefined\n      }\n    | undefined\n  /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n  paymasterContext?: unknown\n  /** User Operation configuration. */\n  userOperation?:\n    | {\n        /** Prepares fee properties for the User Operation request. */\n        estimateFeesPerGas?:\n          | ((parameters: {\n              account: account | SmartAccount\n              bundlerClient: Client\n              userOperation: UserOperationRequest\n            }) => Promise<EstimateFeesPerGasReturnType<'eip1559'>>)\n          | undefined\n      }\n    | undefined\n}\n\nexport type BundlerClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  client extends Client | undefined = Client | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = Prettify<\n  Client<\n    transport,\n    chain extends Chain\n      ? chain\n      : client extends Client<any, infer chain>\n        ? chain\n        : undefined,\n    account,\n    rpcSchema extends RpcSchema\n      ? [...BundlerRpcSchema, ...rpcSchema]\n      : BundlerRpcSchema,\n    BundlerActions<account>\n  >\n> & {\n  client: client\n  paymaster: BundlerClientConfig['paymaster'] | undefined\n  paymasterContext: BundlerClientConfig['paymasterContext'] | undefined\n  userOperation: BundlerClientConfig['userOperation'] | undefined\n}\n\nexport type CreateBundlerClientErrorType = CreateClientErrorType | ErrorType\n\n/**\n * Creates a Bundler Client with a given [Transport](https://viem.sh/docs/clients/intro) configured for a [Chain](https://viem.sh/docs/clients/chains).\n *\n * - Docs: https://viem.sh/account-abstraction/clients/bundler\n *\n * @param config - {@link BundlerClientConfig}\n * @returns A Bundler Client. {@link BundlerClient}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { createBundlerClient } from 'viem/account-abstraction'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const bundlerClient = createBundlerClient({\n *   client,\n *   transport: http('https://public.pimlico.io/v2/1/rpc'),\n * })\n */\nexport function createBundlerClient<\n  transport extends Transport,\n  chain extends Chain | undefined = undefined,\n  account extends SmartAccount | undefined = undefined,\n  client extends Client | undefined = undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n>(\n  parameters: BundlerClientConfig<transport, chain, account, client, rpcSchema>,\n): BundlerClient<transport, chain, account, client, rpcSchema>\n\nexport function createBundlerClient(\n  parameters: BundlerClientConfig,\n): BundlerClient {\n  const {\n    client: client_,\n    key = 'bundler',\n    name = 'Bundler Client',\n    paymaster,\n    paymasterContext,\n    transport,\n    userOperation,\n  } = parameters\n  const client = Object.assign(\n    createClient({\n      ...parameters,\n      chain: parameters.chain ?? client_?.chain,\n      key,\n      name,\n      transport,\n      type: 'bundlerClient',\n    }),\n    { client: client_, paymaster, paymasterContext, userOperation },\n  )\n  return client.extend(bundlerActions) as any\n}\n","import { secp256k1 } from '@noble/curves/secp256k1'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex, Signature } from '../../types/misc.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\n\nexport type ParseSignatureErrorType = NumberToHexErrorType | ErrorType\n\n/**\n * @description Parses a hex formatted signature into a structured signature.\n *\n * @param signatureHex Signature in hex format.\n * @returns The structured signature.\n *\n * @example\n * parseSignature('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // { r: '0x...', s: '0x...', v: 28n }\n */\nexport function parseSignature(signatureHex: Hex) {\n  const { r, s } = secp256k1.Signature.fromCompact(signatureHex.slice(2, 130))\n  const yParityOrV = Number(`0x${signatureHex.slice(130)}`)\n  const [v, yParity] = (() => {\n    if (yParityOrV === 0 || yParityOrV === 1) return [undefined, yParityOrV]\n    if (yParityOrV === 27) return [BigInt(yParityOrV), 0]\n    if (yParityOrV === 28) return [BigInt(yParityOrV), 1]\n    throw new Error('Invalid yParityOrV value')\n  })()\n\n  if (typeof v !== 'undefined')\n    return {\n      r: numberToHex(r, { size: 32 }),\n      s: numberToHex(s, { size: 32 }),\n      v,\n      yParity,\n    } satisfies Signature\n  return {\n    r: numberToHex(r, { size: 32 }),\n    s: numberToHex(s, { size: 32 }),\n    yParity,\n  } satisfies Signature\n}\n","import type { GetCallsStatusReturnType } from '../actions/wallet/getCallsStatus.js'\nimport { BaseError } from './base.js'\n\nexport type BundleFailedErrorType = BundleFailedError & {\n  name: 'BundleFailedError'\n}\nexport class BundleFailedError extends BaseError {\n  result: GetCallsStatusReturnType\n\n  constructor(result: GetCallsStatusReturnType) {\n    super(`Call bundle failed with status: ${result.statusCode}`, {\n      name: 'BundleFailedError',\n    })\n\n    this.result = result\n  }\n}\n","import type { Address, Narrow } from 'abitype'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  AtomicityNotSupportedError,\n  UnsupportedNonOptionalCapabilityError,\n} from '../../errors/rpc.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../types/account.js'\nimport type { Call, Calls } from '../../types/calls.js'\nimport type { ExtractCapabilities } from '../../types/capabilities.js'\nimport type { Chain, DeriveChain } from '../../types/chain.js'\nimport type { WalletSendCallsParameters } from '../../types/eip1193.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { concat } from '../../utils/data/concat.js'\nimport { hexToBigInt } from '../../utils/encoding/fromHex.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport { getTransactionError } from '../../utils/errors/getTransactionError.js'\nimport { sendTransaction } from './sendTransaction.js'\n\nexport const fallbackMagicIdentifier =\n  '0x5792579257925792579257925792579257925792579257925792579257925792'\nexport const fallbackTransactionErrorMagicIdentifier = numberToHex(0, {\n  size: 32,\n})\n\nexport type SendCallsParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _chain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = {\n  chain?: chainOverride | Chain | undefined\n  calls: Calls<Narrow<calls>>\n  capabilities?: ExtractCapabilities<'sendCalls', 'Request'> | undefined\n  experimental_fallback?: boolean | undefined\n  experimental_fallbackDelay?: number | undefined\n  forceAtomic?: boolean | undefined\n  id?: string | undefined\n  version?: WalletSendCallsParameters[number]['version'] | undefined\n} & GetAccountParameter<account, Account | Address, false, true>\n\nexport type SendCallsReturnType = Prettify<{\n  capabilities?: ExtractCapabilities<'sendCalls', 'ReturnType'> | undefined\n  id: string\n}>\n\nexport type SendCallsErrorType = RequestErrorType | ErrorType\n\n/**\n * Requests the connected wallet to send a batch of calls.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendCalls\n * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Transaction identifier. {@link SendCallsReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendCalls } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const id = await sendCalls(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   calls: [\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: 69420n,\n *     },\n *   ],\n * })\n */\nexport async function sendCalls<\n  const calls extends readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SendCallsParameters<chain, account, chainOverride, calls>,\n): Promise<SendCallsReturnType> {\n  const {\n    account: account_ = client.account,\n    capabilities,\n    chain = client.chain,\n    experimental_fallback,\n    experimental_fallbackDelay = 32,\n    forceAtomic = false,\n    id,\n    version = '2.0.0',\n  } = parameters\n\n  const account = account_ ? parseAccount(account_) : null\n\n  const calls = parameters.calls.map((call_: unknown) => {\n    const call = call_ as Call\n\n    const data = call.abi\n      ? encodeFunctionData({\n          abi: call.abi,\n          functionName: call.functionName,\n          args: call.args,\n        })\n      : call.data\n\n    return {\n      data: call.dataSuffix && data ? concat([data, call.dataSuffix]) : data,\n      to: call.to,\n      value: call.value ? numberToHex(call.value) : undefined,\n    }\n  })\n\n  try {\n    const response = await client.request(\n      {\n        method: 'wallet_sendCalls',\n        params: [\n          {\n            atomicRequired: forceAtomic,\n            calls,\n            capabilities,\n            chainId: numberToHex(chain!.id),\n            from: account?.address,\n            id,\n            version,\n          },\n        ],\n      },\n      { retryCount: 0 },\n    )\n    if (typeof response === 'string') return { id: response }\n    return response as never\n  } catch (err) {\n    const error = err as BaseError\n\n    // If the transport does not support EIP-5792, fall back to\n    // `eth_sendTransaction`.\n    if (\n      experimental_fallback &&\n      (error.name === 'MethodNotFoundRpcError' ||\n        error.name === 'MethodNotSupportedRpcError' ||\n        error.name === 'UnknownRpcError' ||\n        error.details\n          .toLowerCase()\n          .includes('does not exist / is not available') ||\n        error.details.toLowerCase().includes('missing or invalid. request()') ||\n        error.details\n          .toLowerCase()\n          .includes('did not match any variant of untagged enum') ||\n        error.details\n          .toLowerCase()\n          .includes('account upgraded to unsupported contract') ||\n        error.details.toLowerCase().includes('eip-7702 not supported') ||\n        error.details.toLowerCase().includes('unsupported wc_ method') ||\n        // magic.link\n        error.details\n          .toLowerCase()\n          .includes('feature toggled misconfigured') ||\n        // Trust Wallet\n        error.details\n          .toLowerCase()\n          .includes(\n            'jsonrpcengine: response has no error or result for request',\n          ))\n    ) {\n      if (capabilities) {\n        const hasNonOptionalCapability = Object.values(capabilities).some(\n          (capability) => !capability.optional,\n        )\n        if (hasNonOptionalCapability) {\n          const message =\n            'non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.'\n          throw new UnsupportedNonOptionalCapabilityError(\n            new BaseError(message, {\n              details: message,\n            }),\n          )\n        }\n      }\n      if (forceAtomic && calls.length > 1) {\n        const message =\n          '`forceAtomic` is not supported on fallback to `eth_sendTransaction`.'\n        throw new AtomicityNotSupportedError(\n          new BaseError(message, {\n            details: message,\n          }),\n        )\n      }\n\n      const promises: Promise<Hex>[] = []\n      for (const call of calls) {\n        const promise = sendTransaction(client, {\n          account,\n          chain,\n          data: call.data,\n          to: call.to,\n          value: call.value ? hexToBigInt(call.value) : undefined,\n        })\n        promises.push(promise)\n\n        // Note: some browser wallets require a small delay between transactions\n        // to prevent duplicate JSON-RPC requests.\n        if (experimental_fallbackDelay > 0)\n          await new Promise((resolve) =>\n            setTimeout(resolve, experimental_fallbackDelay),\n          )\n      }\n\n      const results = await Promise.allSettled(promises)\n      if (results.every((r) => r.status === 'rejected')) throw results[0].reason\n\n      const hashes = results.map((result) => {\n        if (result.status === 'fulfilled') return result.value\n        return fallbackTransactionErrorMagicIdentifier\n      })\n      return {\n        id: concat([\n          ...hashes,\n          numberToHex(chain!.id, { size: 32 }),\n          fallbackMagicIdentifier,\n        ]),\n      }\n    }\n\n    throw getTransactionError(err as BaseError, {\n      ...parameters,\n      account,\n      chain: parameters.chain!,\n    })\n  }\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { ExtractCapabilities } from '../../types/capabilities.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { WalletGetCallsStatusReturnType } from '../../types/eip1193.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RpcTransactionReceipt } from '../../types/rpc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { sliceHex } from '../../utils/data/slice.js'\nimport { trim } from '../../utils/data/trim.js'\nimport { hexToBigInt, hexToNumber } from '../../utils/encoding/fromHex.js'\nimport { receiptStatuses } from '../../utils/formatters/transactionReceipt.js'\nimport {\n  fallbackMagicIdentifier,\n  fallbackTransactionErrorMagicIdentifier,\n} from './sendCalls.js'\n\nexport type GetCallsStatusParameters = { id: string }\n\nexport type GetCallsStatusReturnType = Prettify<\n  Omit<\n    WalletGetCallsStatusReturnType<\n      ExtractCapabilities<'getCallsStatus', 'ReturnType'>,\n      number,\n      bigint,\n      'success' | 'reverted'\n    >,\n    'status'\n  > & {\n    statusCode: number\n    status: 'pending' | 'success' | 'failure' | undefined\n  }\n>\n\nexport type GetCallsStatusErrorType = RequestErrorType | ErrorType\n\n/**\n * Returns the status of a call batch that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/getCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Status of the calls. {@link GetCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const { receipts, status } = await getCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function getCallsStatus<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: GetCallsStatusParameters,\n): Promise<GetCallsStatusReturnType> {\n  async function getStatus(id: Hex) {\n    const isTransactions = id.endsWith(fallbackMagicIdentifier.slice(2))\n    if (isTransactions) {\n      const chainId = trim(sliceHex(id, -64, -32))\n      const hashes = sliceHex(id, 0, -64)\n        .slice(2)\n        .match(/.{1,64}/g)\n\n      const receipts = await Promise.all(\n        hashes!.map((hash) =>\n          fallbackTransactionErrorMagicIdentifier.slice(2) !== hash\n            ? client.request(\n                {\n                  method: 'eth_getTransactionReceipt',\n                  params: [`0x${hash}`],\n                },\n                { dedupe: true },\n              )\n            : undefined,\n        ),\n      )\n\n      const status = (() => {\n        if (receipts.some((r) => r === null)) return 100 // pending\n        if (receipts.every((r) => r?.status === '0x1')) return 200 // success\n        if (receipts.every((r) => r?.status === '0x0')) return 500 // complete failure\n        return 600 // partial failure\n      })()\n\n      return {\n        atomic: false,\n        chainId: hexToNumber(chainId),\n        receipts: receipts.filter(Boolean) as RpcTransactionReceipt[],\n        status,\n        version: '2.0.0',\n      }\n    }\n    return client.request({\n      method: 'wallet_getCallsStatus',\n      params: [id],\n    })\n  }\n\n  const {\n    atomic = false,\n    chainId,\n    receipts,\n    version = '2.0.0',\n    ...response\n  } = await getStatus(parameters.id as Hex)\n  const [status, statusCode] = (() => {\n    const statusCode = response.status\n    if (statusCode >= 100 && statusCode < 200)\n      return ['pending', statusCode] as const\n    if (statusCode >= 200 && statusCode < 300)\n      return ['success', statusCode] as const\n    if (statusCode >= 300 && statusCode < 700)\n      return ['failure', statusCode] as const\n    // @ts-expect-error: for backwards compatibility\n    if (statusCode === 'CONFIRMED') return ['success', 200] as const\n    // @ts-expect-error: for backwards compatibility\n    if (statusCode === 'PENDING') return ['pending', 100] as const\n    return [undefined, statusCode]\n  })()\n  return {\n    ...response,\n    atomic,\n    // @ts-expect-error: for backwards compatibility\n    chainId: chainId ? hexToNumber(chainId) : undefined,\n    receipts:\n      receipts?.map((receipt) => ({\n        ...receipt,\n        blockNumber: hexToBigInt(receipt.blockNumber),\n        gasUsed: hexToBigInt(receipt.gasUsed),\n        status: receiptStatuses[receipt.status as '0x0' | '0x1'],\n      })) ?? [],\n    statusCode,\n    status,\n    version,\n  }\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BaseError } from '../../errors/base.js'\nimport { BundleFailedError } from '../../errors/calls.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { type PollErrorType, poll } from '../../utils/poll.js'\nimport { withResolvers } from '../../utils/promise/withResolvers.js'\nimport {\n  type WithRetryParameters,\n  withRetry,\n} from '../../utils/promise/withRetry.js'\nimport { stringify } from '../../utils/stringify.js'\nimport {\n  type GetCallsStatusErrorType,\n  type GetCallsStatusReturnType,\n  getCallsStatus,\n} from './getCallsStatus.js'\n\nexport type WaitForCallsStatusParameters = {\n  /**\n   * The id of the call batch to wait for.\n   */\n  id: string\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   *\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * Number of times to retry if the call bundle failed.\n   * @default 4 (exponential backoff)\n   */\n  retryCount?: WithRetryParameters['retryCount'] | undefined\n  /**\n   * Time to wait (in ms) between retries.\n   * @default `({ count }) => ~~(1 << count) * 200` (exponential backoff)\n   */\n  retryDelay?: WithRetryParameters['delay'] | undefined\n  /**\n   * The status range to wait for.\n   *\n   * @default (status) => status >= 200\n   */\n  status?: ((parameters: GetCallsStatusReturnType) => boolean) | undefined\n  /**\n   * Whether to throw an error if the call bundle fails.\n   *\n   * @default false\n   */\n  throwOnFailure?: boolean | undefined\n  /**\n   * Optional timeout (in milliseconds) to wait before stopping polling.\n   *\n   * @default 60_000\n   */\n  timeout?: number | undefined\n}\n\nexport type WaitForCallsStatusReturnType = GetCallsStatusReturnType\n\nexport type WaitForCallsStatusErrorType =\n  | ObserveErrorType\n  | PollErrorType\n  | GetCallsStatusErrorType\n  | WaitForCallsStatusTimeoutError\n  | ErrorType\n\n/**\n * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/waitForCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForCallsStatusParameters}\n * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function waitForCallsStatus<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: WaitForCallsStatusParameters,\n): Promise<WaitForCallsStatusReturnType> {\n  const {\n    id,\n    pollingInterval = client.pollingInterval,\n    status = ({ statusCode }) => statusCode === 200 || statusCode >= 300,\n    retryCount = 4,\n    retryDelay = ({ count }) => ~~(1 << count) * 200, // exponential backoff\n    timeout = 60_000,\n    throwOnFailure = false,\n  } = parameters\n  const observerId = stringify(['waitForCallsStatus', client.uid, id])\n\n  const { promise, resolve, reject } =\n    withResolvers<WaitForCallsStatusReturnType>()\n\n  let timer: Timer | undefined\n\n  const unobserve = observe(observerId, { resolve, reject }, (emit) => {\n    const unpoll = poll(\n      async () => {\n        const done = (fn: () => void) => {\n          clearTimeout(timer)\n          unpoll()\n          fn()\n          unobserve()\n        }\n\n        try {\n          const result = await withRetry(\n            async () => {\n              const result = await getAction(\n                client,\n                getCallsStatus,\n                'getCallsStatus',\n              )({ id })\n              if (throwOnFailure && result.status === 'failure')\n                throw new BundleFailedError(result)\n              return result\n            },\n            {\n              retryCount,\n              delay: retryDelay,\n            },\n          )\n          if (!status(result)) return\n          done(() => emit.resolve(result))\n        } catch (error) {\n          done(() => emit.reject(error))\n        }\n      },\n      {\n        interval: pollingInterval,\n        emitOnBegin: true,\n      },\n    )\n\n    return unpoll\n  })\n\n  timer = timeout\n    ? setTimeout(() => {\n        unobserve()\n        clearTimeout(timer)\n        reject(new WaitForCallsStatusTimeoutError({ id }))\n      }, timeout)\n    : undefined\n\n  return await promise\n}\n\nexport type WaitForCallsStatusTimeoutErrorType =\n  WaitForCallsStatusTimeoutError & {\n    name: 'WaitForCallsStatusTimeoutError'\n  }\nexport class WaitForCallsStatusTimeoutError extends BaseError {\n  constructor({ id }: { id: string }) {\n    super(\n      `Timed out while waiting for call bundle with id \"${id}\" to be confirmed.`,\n      { name: 'WaitForCallsStatusTimeoutError' },\n    )\n  }\n}\n","import type { Address } from 'abitype'\n\nimport { getTransactionCount } from '../actions/public/getTransactionCount.js'\nimport type { Client } from '../clients/createClient.js'\nimport type { MaybePromise } from '../types/utils.js'\nimport { LruMap } from './lru.js'\n\nexport type CreateNonceManagerParameters = {\n  source: NonceManagerSource\n}\n\ntype FunctionParameters = {\n  address: Address\n  chainId: number\n}\n\nexport type NonceManager = {\n  /** Get and increment a nonce. */\n  consume: (\n    parameters: FunctionParameters & { client: Client },\n  ) => Promise<number>\n  /** Increment a nonce. */\n  increment: (chainId: FunctionParameters) => void\n  /** Get a nonce. */\n  get: (chainId: FunctionParameters & { client: Client }) => Promise<number>\n  /** Reset a nonce. */\n  reset: (chainId: FunctionParameters) => void\n}\n\n/**\n * Creates a nonce manager for auto-incrementing transaction nonces.\n *\n * - Docs: https://viem.sh/docs/accounts/createNonceManager\n *\n * @example\n * ```ts\n * const nonceManager = createNonceManager({\n *   source: jsonRpc(),\n * })\n * ```\n */\nexport function createNonceManager(\n  parameters: CreateNonceManagerParameters,\n): NonceManager {\n  const { source } = parameters\n\n  const deltaMap = new Map()\n  const nonceMap = new LruMap<number>(8192)\n  const promiseMap = new Map<string, Promise<number>>()\n\n  const getKey = ({ address, chainId }: FunctionParameters) =>\n    `${address}.${chainId}`\n\n  return {\n    async consume({ address, chainId, client }) {\n      const key = getKey({ address, chainId })\n      const promise = this.get({ address, chainId, client })\n\n      this.increment({ address, chainId })\n      const nonce = await promise\n\n      await source.set({ address, chainId }, nonce)\n      nonceMap.set(key, nonce)\n\n      return nonce\n    },\n    async increment({ address, chainId }) {\n      const key = getKey({ address, chainId })\n      const delta = deltaMap.get(key) ?? 0\n      deltaMap.set(key, delta + 1)\n    },\n    async get({ address, chainId, client }) {\n      const key = getKey({ address, chainId })\n\n      let promise = promiseMap.get(key)\n      if (!promise) {\n        promise = (async () => {\n          try {\n            const nonce = await source.get({ address, chainId, client })\n            const previousNonce = nonceMap.get(key) ?? 0\n            if (previousNonce > 0 && nonce <= previousNonce)\n              return previousNonce + 1\n            nonceMap.delete(key)\n            return nonce\n          } finally {\n            this.reset({ address, chainId })\n          }\n        })()\n        promiseMap.set(key, promise)\n      }\n\n      const delta = deltaMap.get(key) ?? 0\n      return delta + (await promise)\n    },\n    reset({ address, chainId }) {\n      const key = getKey({ address, chainId })\n      deltaMap.delete(key)\n      promiseMap.delete(key)\n    },\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////\n// Sources\n\nexport type NonceManagerSource = {\n  /** Get a nonce. */\n  get(parameters: FunctionParameters & { client: Client }): MaybePromise<number>\n  /** Set a nonce. */\n  set(parameters: FunctionParameters, nonce: number): MaybePromise<void>\n}\n\n/** JSON-RPC source for a nonce manager. */\nexport function jsonRpc(): NonceManagerSource {\n  return {\n    async get(parameters) {\n      const { address, client } = parameters\n      return getTransactionCount(client, {\n        address,\n        blockTag: 'pending',\n      })\n    },\n    set() {},\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////\n// Default\n\n/** Default Nonce Manager with a JSON-RPC source. */\nexport const nonceManager = /*#__PURE__*/ createNonceManager({\n  source: jsonRpc(),\n})\n","export const erc6492MagicBytes =\n  '0x6492649264926492649264926492649264926492649264926492649264926492' as const\n\nexport const zeroHash =\n  '0x0000000000000000000000000000000000000000000000000000000000000000' as const\n","import type { Address } from 'abitype'\nimport { erc6492MagicBytes } from '../../constants/bytes.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { encodeAbiParameters } from '../abi/encodeAbiParameters.js'\nimport { concatHex } from '../data/concat.js'\nimport { hexToBytes } from '../encoding/toBytes.js'\n\ntype To = 'bytes' | 'hex'\n\nexport type SerializeErc6492SignatureParameters<to extends To = 'hex'> = {\n  /** The ERC-4337 Account Factory address to use for counterfactual verification. */\n  address: Address\n  /** Calldata to pass to deploy account (if not deployed) for counterfactual verification. */\n  data: Hex\n  /** The original signature. */\n  signature: Hex\n  to?: to | To | undefined\n}\n\nexport type SerializeErc6492SignatureReturnType<to extends To = 'hex'> =\n  | (to extends 'hex' ? Hex : never)\n  | (to extends 'bytes' ? ByteArray : never)\n\nexport type SerializeErc6492SignatureErrorType = ErrorType\n\n/**\n * @description Serializes a ERC-6492 flavoured signature into hex format.\n *\n * @param signature ERC-6492 signature in object format.\n * @returns ERC-6492 signature in hex format.\n *\n * @example\n * serializeSignature({ address: '0x...', data: '0x...', signature: '0x...' })\n * // '0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492'\n */\nexport function serializeErc6492Signature<to extends To = 'hex'>(\n  parameters: SerializeErc6492SignatureParameters<to>,\n): SerializeErc6492SignatureReturnType<to> {\n  const { address, data, signature, to = 'hex' } = parameters\n  const signature_ = concatHex([\n    encodeAbiParameters(\n      [{ type: 'address' }, { type: 'bytes' }, { type: 'bytes' }],\n      [address, data, signature],\n    ),\n    erc6492MagicBytes,\n  ])\n\n  if (to === 'hex') return signature_ as SerializeErc6492SignatureReturnType<to>\n  return hexToBytes(signature_) as SerializeErc6492SignatureReturnType<to>\n}\n","import { type Abi, parseAbi } from 'abitype'\n\nimport { getCode } from '../../actions/public/getCode.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { createNonceManager } from '../../utils/nonceManager.js'\nimport { serializeErc6492Signature } from '../../utils/signature/serializeErc6492Signature.js'\nimport type { EntryPointVersion } from '../types/entryPointVersion.js'\nimport type { SmartAccount, SmartAccountImplementation } from './types.js'\n\nexport type ToSmartAccountParameters<\n  entryPointAbi extends Abi | readonly unknown[] = Abi,\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n  extend extends object = object,\n> = SmartAccountImplementation<entryPointAbi, entryPointVersion, extend>\n\nexport type ToSmartAccountReturnType<\n  implementation extends\n    SmartAccountImplementation = SmartAccountImplementation,\n> = Prettify<SmartAccount<implementation>>\n\n/**\n * @description Creates a Smart Account with a provided account implementation.\n *\n * @param parameters - {@link ToSmartAccountParameters}\n * @returns A Smart Account. {@link ToSmartAccountReturnType}\n */\nexport async function toSmartAccount<\n  implementation extends SmartAccountImplementation,\n>(\n  implementation: implementation,\n): Promise<ToSmartAccountReturnType<implementation>> {\n  const {\n    extend,\n    nonceKeyManager = createNonceManager({\n      source: {\n        get() {\n          return Date.now()\n        },\n        set() {},\n      },\n    }),\n    ...rest\n  } = implementation\n\n  let deployed = false\n\n  const address = await implementation.getAddress()\n\n  return {\n    ...extend,\n    ...rest,\n    address,\n    async getFactoryArgs() {\n      if ('isDeployed' in this && (await this.isDeployed()))\n        return { factory: undefined, factoryData: undefined }\n      return implementation.getFactoryArgs()\n    },\n    async getNonce(parameters) {\n      const key =\n        parameters?.key ??\n        BigInt(\n          await nonceKeyManager.consume({\n            address,\n            chainId: implementation.client.chain!.id!,\n            client: implementation.client,\n          }),\n        )\n\n      if (implementation.getNonce)\n        return await implementation.getNonce({ ...parameters, key })\n\n      const nonce = await readContract(implementation.client, {\n        abi: parseAbi([\n          'function getNonce(address, uint192) pure returns (uint256)',\n        ]),\n        address: implementation.entryPoint.address,\n        functionName: 'getNonce',\n        args: [address, key],\n      })\n      return nonce\n    },\n    async isDeployed() {\n      if (deployed) return true\n      const code = await getAction(\n        implementation.client,\n        getCode,\n        'getCode',\n      )({\n        address,\n      })\n      deployed = Boolean(code)\n      return deployed\n    },\n    ...(implementation.sign\n      ? {\n          async sign(parameters) {\n            const [{ factory, factoryData }, signature] = await Promise.all([\n              this.getFactoryArgs(),\n              implementation.sign!(parameters),\n            ])\n            if (factory && factoryData)\n              return serializeErc6492Signature({\n                address: factory,\n                data: factoryData,\n                signature,\n              })\n            return signature\n          },\n        }\n      : {}),\n    async signMessage(parameters) {\n      const [{ factory, factoryData }, signature] = await Promise.all([\n        this.getFactoryArgs(),\n        implementation.signMessage(parameters),\n      ])\n      if (factory && factoryData && factory !== '0x7702')\n        return serializeErc6492Signature({\n          address: factory,\n          data: factoryData,\n          signature,\n        })\n      return signature\n    },\n    async signTypedData(parameters) {\n      const [{ factory, factoryData }, signature] = await Promise.all([\n        this.getFactoryArgs(),\n        implementation.signTypedData(parameters),\n      ])\n      if (factory && factoryData && factory !== '0x7702')\n        return serializeErc6492Signature({\n          address: factory,\n          data: factoryData,\n          signature,\n        })\n      return signature\n    },\n    type: 'smart',\n  } as ToSmartAccountReturnType<implementation>\n}\n","import type { Address } from 'abitype'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Account, ParseAccount } from '../types/account.js'\nimport type { Chain } from '../types/chain.js'\nimport type { PublicRpcSchema, RpcSchema } from '../types/eip1193.js'\nimport type { Prettify } from '../types/utils.js'\nimport {\n  type Client,\n  type ClientConfig,\n  type CreateClientErrorType,\n  createClient,\n} from './createClient.js'\nimport { type PublicActions, publicActions } from './decorators/public.js'\nimport type { Transport } from './transports/createTransport.js'\n\nexport type PublicClientConfig<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  accountOrAddress extends Account | Address | undefined = undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = Prettify<\n  Pick<\n    ClientConfig<transport, chain, accountOrAddress, rpcSchema>,\n    | 'batch'\n    | 'cacheTime'\n    | 'ccipRead'\n    | 'chain'\n    | 'experimental_blockTag'\n    | 'key'\n    | 'name'\n    | 'pollingInterval'\n    | 'rpcSchema'\n    | 'transport'\n  >\n>\n\nexport type PublicClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  accountOrAddress extends Account | undefined = undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = Prettify<\n  Client<\n    transport,\n    chain,\n    accountOrAddress,\n    rpcSchema extends RpcSchema\n      ? [...PublicRpcSchema, ...rpcSchema]\n      : PublicRpcSchema,\n    PublicActions<transport, chain>\n  >\n>\n\nexport type CreatePublicClientErrorType = CreateClientErrorType | ErrorType\n\n/**\n * Creates a Public Client with a given [Transport](https://viem.sh/docs/clients/intro) configured for a [Chain](https://viem.sh/docs/clients/chains).\n *\n * - Docs: https://viem.sh/docs/clients/public\n *\n * A Public Client is an interface to \"public\" [JSON-RPC API](https://ethereum.org/en/developers/docs/apis/json-rpc/) methods such as retrieving block numbers, transactions, reading from smart contracts, etc through [Public Actions](/docs/actions/public/introduction).\n *\n * @param config - {@link PublicClientConfig}\n * @returns A Public Client. {@link PublicClient}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n */\nexport function createPublicClient<\n  transport extends Transport,\n  chain extends Chain | undefined = undefined,\n  accountOrAddress extends Account | Address | undefined = undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n>(\n  parameters: PublicClientConfig<transport, chain, accountOrAddress, rpcSchema>,\n): PublicClient<transport, chain, ParseAccount<accountOrAddress>, rpcSchema> {\n  const { key = 'public', name = 'Public Client' } = parameters\n  const client = createClient({\n    ...parameters,\n    key,\n    name,\n    type: 'publicClient',\n  })\n  return client.extend(publicActions) as any\n}\n","/**\n * Internal module for NIST P256, P384, P521 curves.\n * Do not use for now.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256, sha384, sha512 } from '@noble/hashes/sha2';\nimport { createCurve, type CurveFnWithCreate } from './_shortw_utils.ts';\nimport { createHasher, type Hasher } from './abstract/hash-to-curve.ts';\nimport { Field } from './abstract/modular.ts';\nimport { mapToCurveSimpleSWU } from './abstract/weierstrass.ts';\n\nconst Fp256 = Field(BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'));\nconst p256_a = Fp256.create(BigInt('-3'));\nconst p256_b = BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b');\n\n/**\n * secp256r1 curve, ECDSA and ECDH methods.\n * Field: `2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n`\n */\n// prettier-ignore\nexport const p256: CurveFnWithCreate = createCurve({\n  a: p256_a,\n  b: p256_b,\n  Fp: Fp256,\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n  h: BigInt(1),\n  lowS: false\n} as const, sha256);\n/** Alias to p256. */\nexport const secp256r1: CurveFnWithCreate = p256;\n\nconst p256_mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp256, {\n    A: p256_a,\n    B: p256_b,\n    Z: Fp256.create(BigInt('-10')),\n  }))();\n\n/** Hashing / encoding to p256 points / field. RFC 9380 methods. */\nexport const p256_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(secp256r1.ProjectivePoint, (scalars: bigint[]) => p256_mapSWU(scalars[0]), {\n    DST: 'P256_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'P256_XMD:SHA-256_SSWU_NU_',\n    p: Fp256.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n  }))();\n\n// Field over which we'll do calculations.\nconst Fp384 = Field(\n  BigInt(\n    '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff'\n  )\n);\nconst p384_a = Fp384.create(BigInt('-3'));\n// prettier-ignore\nconst p384_b = BigInt('0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef');\n\n/**\n * secp384r1 curve, ECDSA and ECDH methods.\n * Field: `2n**384n - 2n**128n - 2n**96n + 2n**32n - 1n`.\n * */\n// prettier-ignore\nexport const p384: CurveFnWithCreate = createCurve({\n  a: p384_a,\n  b: p384_b,\n  Fp: Fp384,\n  n: BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973'),\n  Gx: BigInt('0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7'),\n  Gy: BigInt('0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f'),\n  h: BigInt(1),\n  lowS: false\n} as const, sha384);\n/** Alias to p384. */\nexport const secp384r1: CurveFnWithCreate = p384;\n\nconst p384_mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp384, {\n    A: p384_a,\n    B: p384_b,\n    Z: Fp384.create(BigInt('-12')),\n  }))();\n\n/** Hashing / encoding to p384 points / field. RFC 9380 methods. */\nexport const p384_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(secp384r1.ProjectivePoint, (scalars: bigint[]) => p384_mapSWU(scalars[0]), {\n    DST: 'P384_XMD:SHA-384_SSWU_RO_',\n    encodeDST: 'P384_XMD:SHA-384_SSWU_NU_',\n    p: Fp384.ORDER,\n    m: 1,\n    k: 192,\n    expand: 'xmd',\n    hash: sha384,\n  }))();\n\n// Field over which we'll do calculations.\nconst Fp521 = Field(\n  BigInt(\n    '0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n  )\n);\n\nconst p521_a = Fp521.create(BigInt('-3'));\nconst p521_b = BigInt(\n  '0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00'\n);\n\n/**\n * NIST secp521r1 aka p521 curve, ECDSA and ECDH methods.\n * Field: `2n**521n - 1n`.\n */\n// prettier-ignore\nexport const p521: CurveFnWithCreate = createCurve({\n  a: p521_a,\n  b: p521_b,\n  Fp: Fp521,\n  n: BigInt(\n    '0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409'\n  ),\n  Gx: BigInt(\n    '0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66'\n  ),\n  Gy: BigInt(\n    '0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650'\n  ),\n  h: BigInt(1),\n  lowS: false,\n  allowedPrivateKeyLengths: [130, 131, 132] // P521 keys are variable-length. Normalize to 132b\n} as const, sha512);\n/** Alias to p521. */\nexport const secp521r1: CurveFnWithCreate = p521;\n\nconst p521_mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp521, {\n    A: p521_a,\n    B: p521_b,\n    Z: Fp521.create(BigInt('-4')),\n  }))();\n\n/** Hashing / encoding to p521 points / field. RFC 9380 methods. */\nexport const p521_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(secp521r1.ProjectivePoint, (scalars: bigint[]) => p521_mapSWU(scalars[0]), {\n    DST: 'P521_XMD:SHA-512_SSWU_RO_',\n    encodeDST: 'P521_XMD:SHA-512_SSWU_NU_',\n    p: Fp521.ORDER,\n    m: 1,\n    k: 256,\n    expand: 'xmd',\n    hash: sha512,\n  }))();\n","/**\n * NIST secp256r1 aka p256.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { type HTFMethod } from './abstract/hash-to-curve.ts';\nimport { p256_hasher, p256 as p256n } from './nist.ts';\nexport const p256: typeof p256n = p256n;\nexport const secp256r1: typeof p256n = p256n;\nexport const hashToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => p256_hasher.hashToCurve)();\nexport const encodeToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => p256_hasher.encodeToCurve)();\n"],"names":["encodePacked","types","values","length","AbiEncodingLengthMismatchError","expectedLength","givenLength","data","i","type","value","push","encode","concatHex","isArray","arguments","undefined","address","isAddress","InvalidAddressError","pad","toLowerCase","size","stringToHex","boolToHex","intMatch","match","integerRegex","_type","baseType","bits","Number","parseInt","numberToHex","signed","bytesMatch","bytesRegex","BytesSizeMismatchError","expectedSize","givenSize","dir","arrayMatch","arrayRegex","Array","childType","UnsupportedPackedAbiType","promisifyRequest","request","Promise","resolve","reject","oncomplete","onsuccess","result","onabort","onerror","error","createStore","dbName","storeName","indexedDB","open","onupgradeneeded","createObjectStore","dbp","txMode","callback","then","db","transaction","objectStore","defaultGetStoreFunc","defaultGetStore","get","key","store","set","put","del","delete","clear","eachCursor","openCursor","this","continue","keys","getAllKeys","items","cursor","getInitCode","userOperation","authorization","factory","factoryData","delegation","concat","toPackedUserOperation","_userOperation$nonce","_userOperation$preVer","callGasLimit","callData","maxPriorityFeePerGas","maxFeePerGas","paymaster","paymasterData","paymasterPostOpGasLimit","paymasterVerificationGasLimit","sender","signature","verificationGasLimit","accountGasLimits","initCode","gasFees","nonce","paymasterAndData","preVerificationGas","PackedUserOperation","name","getUserOperationHash","parameters","chainId","entryPointAddress","entryPointVersion","hashTypedData","packedUserOp","primaryType","domain","version","verifyingContract","message","getUserOperationTypedData","_userOperation$initCo","_userOperation$initCo2","slice","encodeAbiParameters","keccak256","Error","BigInt","entryPoint06Address","createStoreImpl","createState","state","listeners","Set","setState","partial","replace","nextState","Object","is","previousState","assign","forEach","listener","getState","api","getInitialState","initialState","subscribe","add","entryPoint06Abi","inputs","components","anonymous","indexed","outputs","stateMutability","createJSONStorage","getStorage","options","storage","e","getItem","_a","parse","str2","JSON","reviver","str","setItem","newValue","stringify","replacer","removeItem","toThenable","fn","input","onFulfilled","catch","_onRejected","_onFulfilled","onRejected","persist","persistImpl","config","baseOptions","_objectSpread","localStorage","partialize","merge","persistedState","currentState","hasHydrated","hydrationListeners","finishHydrationListeners","console","warn","savedSetState","configResult","stateFromStorage","hydrate","_b","cb","_a2","postRehydrationCallback","onRehydrateStorage","call","bind","deserializedStorageValue","migrate","migration","migrationResult","migrated","migratedState","setOptions","newOptions","clearStorage","getOptions","rehydrate","onHydrate","onFinishHydration","skipHydration","AccountNotDeployedError","BaseError","constructor","_ref","cause","super","metaMessages","defineProperty","ExecutionRevertedError","_message$replace","reason","FailedToSendToBeneficiaryError","_ref2","GasValuesOverflowError","_ref3","filter","Boolean","HandleOpsOutOfGasError","_ref4","InitCodeFailedError","_ref5","InitCodeMustCreateSenderError","_ref6","InitCodeMustReturnSenderError","_ref7","InsufficientPrefundError","_ref8","InternalCallOnlyError","_ref9","InvalidAggregatorError","_ref0","InvalidAccountNonceError","_ref1","InvalidBeneficiaryError","_ref10","InvalidFieldsError","_ref11","InvalidPaymasterAndDataError","_ref12","PaymasterDepositTooLowError","_ref13","PaymasterFunctionRevertedError","_ref14","PaymasterNotDeployedError","_ref15","PaymasterRateLimitError","_ref16","PaymasterStakeTooLowError","_ref17","PaymasterPostOpFunctionRevertedError","_ref18","SenderAlreadyConstructedError","_ref19","SignatureCheckFailedError","_ref20","SmartAccountFunctionRevertedError","_ref21","UnsupportedSignatureAggregatorError","_ref22","UserOperationExpiredError","_ref23","UserOperationPaymasterExpiredError","_ref24","UserOperationSignatureError","_ref25","UserOperationPaymasterSignatureError","_ref26","UserOperationRejectedByEntryPointError","_ref27","UserOperationRejectedByPaymasterError","_ref28","UserOperationRejectedByOpCodeError","_ref29","UserOperationOutOfTimeRangeError","_ref30","UnknownBundlerError","_ref31","shortMessage","VerificationGasLimitExceededError","_ref32","VerificationGasLimitTooLowError","_ref33","UserOperationExecutionError","docsPath","prettyArgs","prettyPrint","formatGwei","UserOperationReceiptNotFoundError","hash","UserOperationNotFoundError","WaitForUserOperationReceiptTimeoutError","bundlerErrors","getUserOperationError","err","calls","args","_objectWithoutProperties","_excluded","details","test","walk","some","code","getBundlerError","revertData","_error$data","_match","_error$data2","getRevertData","contractCalls","abi","functionName","to","compatContractCalls","decodeErrorResult","_unused","reduce","acc","ContractFunctionZeroDataError","ContractFunctionRevertedError","ContractFunctionExecutionError","contractAddress","getContractError","formatUserOperationRequest","rpcRequest","eip7702Auth","r","s","yParity","async","getPaymasterData","client","_request$callGasLimit","_request$verification","_request$preVerificat","context","_await$client$request","method","params","rest","_excluded2","hexToBigInt","getPaymasterStubData","defaultParameters","prepareUserOperation","parameters_","_parameters$paymaster","account","account_","properties","stateOverride","AccountNotFoundError","parseAccount","bundlerClient","paymasterAddress","getAction","getPaymasterStubData_","getPaymasterData_","paymasterContext","fees","all","encodeCalls","map","call_","encodeFunctionData","includes","getFactoryArgs","entryPoint","_bundlerClient$userOp","estimateFeesPerGas","_bundlerClient$client","client_","chain","getNonce","isDeployed","_parameters$contractA","_client$chain$id","_client$chain","executor","id","getChainId","getTransactionCount","blockTag","isAddressEqual","prepareAuthorization","chainId_","getChainId_","getStubSignature","isPaymasterPopulated","_await$getPaymasterSt","isFinal","sponsor","_","paymasterArgs","_account$userOperatio","estimateGas","gas","_request$paymasterPos","_request$paymasterVer","estimateUserOperationGas","rpcStateOverride","serializeStateOverride","_account$entryPoint","formatUserOperationGas","formatUserOperation","getUserOperationReceipt","receipt","dedupe","actualGasCost","actualGasUsed","logs","log","formatLog","formatTransactionReceipt","formatUserOperationReceipt","bundlerActions","getSupportedEntryPoints","getUserOperation","blockHash","blockNumber","transactionHash","sendUserOperation","_account$signUserOper","signUserOperation","rpcParameters","retryCount","waitForUserOperationReceipt","pollingInterval","timeout","count","observerId","uid","unobserve","observe","emit","done","unpoll","poll","emitOnBegin","interval","setTimeout","createBundlerClient","_parameters$chain","transport","createClient","extend","parseSignature","signatureHex","secp256k1","Signature","fromCompact","yParityOrV","v","BundleFailedError","statusCode","fallbackMagicIdentifier","fallbackTransactionErrorMagicIdentifier","getCallsStatus","_receipts$map","_await$getStatus","endsWith","trim","sliceHex","hashes","receipts","status","every","atomic","hexToNumber","getStatus","response","gasUsed","receiptStatuses","waitForCallsStatus","retryDelay","throwOnFailure","promise","withResolvers","timer","clearTimeout","withRetry","delay","WaitForCallsStatusTimeoutError","createNonceManager","source","deltaMap","Map","nonceMap","LruMap","promiseMap","getKey","consume","increment","_deltaMap$get","delta","_deltaMap$get2","_nonceMap$get","previousNonce","reset","erc6492MagicBytes","serializeErc6492Signature","signature_","hexToBytes","toSmartAccount","implementation","nonceKeyManager","Date","now","deployed","getAddress","_parameters$key","readContract","parseAbi","getCode","sign","signMessage","signTypedData","createPublicClient","publicActions","Fp256","Field","p256_a","create","p256_b","p256","createCurve","a","b","Fp","n","Gx","Gy","h","lowS","sha256","Fp384","p384_a","p384_b","Fp521","sha384","p521_a","p521_b","allowedPrivateKeyLengths","sha512","p256n"],"sourceRoot":""}